/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AciNetworkProviderObservation struct {
}

type AciNetworkProviderParameters struct {

	// +kubebuilder:validation:Required
	Aep *string `json:"aep" tf:"aep,omitempty"`

	// +kubebuilder:validation:Required
	ApicHosts []*string `json:"apicHosts" tf:"apic_hosts,omitempty"`

	// +kubebuilder:validation:Required
	ApicUserCrtSecretRef v1.SecretKeySelector `json:"apicUserCrtSecretRef" tf:"-"`

	// +kubebuilder:validation:Required
	ApicUserKeySecretRef v1.SecretKeySelector `json:"apicUserKeySecretRef" tf:"-"`

	// +kubebuilder:validation:Required
	ApicUserName *string `json:"apicUserName" tf:"apic_user_name,omitempty"`

	// +kubebuilder:validation:Required
	EncapType *string `json:"encapType" tf:"encap_type,omitempty"`

	// +kubebuilder:validation:Required
	ExternDynamic *string `json:"externDynamic" tf:"extern_dynamic,omitempty"`

	// +kubebuilder:validation:Required
	ExternStatic *string `json:"externStatic" tf:"extern_static,omitempty"`

	// +kubebuilder:validation:Required
	InfraVlan *string `json:"infraVlan" tf:"infra_vlan,omitempty"`

	// +kubebuilder:validation:Required
	KubeAPIVlan *string `json:"kubeApiVlan" tf:"kube_api_vlan,omitempty"`

	// +kubebuilder:validation:Required
	L3Out *string `json:"l3out" tf:"l3out,omitempty"`

	// +kubebuilder:validation:Required
	L3OutExternalNetworks []*string `json:"l3outExternalNetworks" tf:"l3out_external_networks,omitempty"`

	// +kubebuilder:validation:Required
	McastRangeEnd *string `json:"mcastRangeEnd" tf:"mcast_range_end,omitempty"`

	// +kubebuilder:validation:Required
	McastRangeStart *string `json:"mcastRangeStart" tf:"mcast_range_start,omitempty"`

	// +kubebuilder:validation:Required
	NodeSubnet *string `json:"nodeSubnet" tf:"node_subnet,omitempty"`

	// +kubebuilder:validation:Required
	NodeSvcSubnet *string `json:"nodeSvcSubnet" tf:"node_svc_subnet,omitempty"`

	// +kubebuilder:validation:Required
	ServiceVlan *string `json:"serviceVlan" tf:"service_vlan,omitempty"`

	// +kubebuilder:validation:Optional
	SnatPortRangeEnd *string `json:"snatPortRangeEnd,omitempty" tf:"snat_port_range_end,omitempty"`

	// +kubebuilder:validation:Optional
	SnatPortRangeStart *string `json:"snatPortRangeStart,omitempty" tf:"snat_port_range_start,omitempty"`

	// +kubebuilder:validation:Optional
	SnatPortsPerNode *string `json:"snatPortsPerNode,omitempty" tf:"snat_ports_per_node,omitempty"`

	// +kubebuilder:validation:Required
	SystemID *string `json:"systemId" tf:"system_id,omitempty"`

	// +kubebuilder:validation:Required
	TokenSecretRef v1.SecretKeySelector `json:"tokenSecretRef" tf:"-"`

	// +kubebuilder:validation:Required
	VrfName *string `json:"vrfName" tf:"vrf_name,omitempty"`

	// +kubebuilder:validation:Required
	VrfTenant *string `json:"vrfTenant" tf:"vrf_tenant,omitempty"`
}

type AuditLogConfigurationObservation struct {
}

type AuditLogConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	Format *string `json:"format,omitempty" tf:"format,omitempty"`

	// +kubebuilder:validation:Optional
	MaxAge *float64 `json:"maxAge,omitempty" tf:"max_age,omitempty"`

	// +kubebuilder:validation:Optional
	MaxBackup *float64 `json:"maxBackup,omitempty" tf:"max_backup,omitempty"`

	// +kubebuilder:validation:Optional
	MaxSize *float64 `json:"maxSize,omitempty" tf:"max_size,omitempty"`

	// +kubebuilder:validation:Optional
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// +kubebuilder:validation:Optional
	Policy *string `json:"policy,omitempty" tf:"policy,omitempty"`
}

type AuditLogObservation struct {
}

type AuditLogParameters struct {

	// +kubebuilder:validation:Optional
	Configuration []ConfigurationParameters `json:"configuration,omitempty" tf:"configuration,omitempty"`

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type AuthenticationObservation struct {
}

type AuthenticationParameters struct {

	// List of additional hostnames and IPs to include in the api server PKI cert
	// +kubebuilder:validation:Optional
	Sans []*string `json:"sans,omitempty" tf:"sans,omitempty"`

	// Authentication strategy that will be used in RKE k8s cluster
	// +kubebuilder:validation:Optional
	Strategy *string `json:"strategy,omitempty" tf:"strategy,omitempty"`

	// Webhook configuration options
	// +kubebuilder:validation:Optional
	Webhook []WebhookParameters `json:"webhook,omitempty" tf:"webhook,omitempty"`
}

type AuthorizationObservation struct {
}

type AuthorizationParameters struct {

	// +kubebuilder:validation:Optional
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// Authorization mode options
	// +kubebuilder:validation:Optional
	Options map[string]*string `json:"options,omitempty" tf:"options,omitempty"`
}

type AwsCloudConfigObservation struct {
}

type AwsCloudConfigParameters struct {

	// +kubebuilder:validation:Optional
	Global []GlobalParameters `json:"global,omitempty" tf:"global,omitempty"`

	// +kubebuilder:validation:Optional
	ServiceOverride []ServiceOverrideParameters `json:"serviceOverride,omitempty" tf:"service_override,omitempty"`
}

type AwsCloudProviderGlobalObservation struct {
}

type AwsCloudProviderGlobalParameters struct {

	// Disables the automatic ingress creation
	// +kubebuilder:validation:Optional
	DisableSecurityGroupIngress *bool `json:"disableSecurityGroupIngress,omitempty" tf:"disable_security_group_ingress,omitempty"`

	// Setting this to true will disable the check and provide a warning that the check was skipped
	// +kubebuilder:validation:Optional
	DisableStrictZoneCheck *bool `json:"disableStrictZoneCheck,omitempty" tf:"disable_strict_zone_check,omitempty"`

	// Use these ELB security groups instead create new
	// +kubebuilder:validation:Optional
	ELBSecurityGroup *string `json:"elbSecurityGroup,omitempty" tf:"elb_security_group,omitempty"`

	// The cluster id we'll use to identify our cluster resources
	// +kubebuilder:validation:Optional
	KubernetesClusterID *string `json:"kubernetesClusterId,omitempty" tf:"kubernetes_cluster_id,omitempty"`

	// Legacy cluster id we'll use to identify our cluster resources
	// +kubebuilder:validation:Optional
	KubernetesClusterTag *string `json:"kubernetesClusterTag,omitempty" tf:"kubernetes_cluster_tag,omitempty"`

	// IAM role to assume when interaction with AWS APIs
	// +kubebuilder:validation:Optional
	RoleArn *string `json:"roleArn,omitempty" tf:"role_arn,omitempty"`

	// Enables using a specific RouteTable
	// +kubebuilder:validation:Optional
	RouteTableID *string `json:"routeTableId,omitempty" tf:"route_table_id,omitempty"`

	// Enables using a specific subnet to use for ELB's
	// +kubebuilder:validation:Optional
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`

	// The AWS VPC flag enables the possibility to run the master components on a different aws account, on a different cloud provider or on-premises. If the flag is set also the KubernetesClusterTag must be provided
	// +kubebuilder:validation:Optional
	VPC *string `json:"vpc,omitempty" tf:"vpc,omitempty"`

	// The AWS zone
	// +kubebuilder:validation:Optional
	Zone *string `json:"zone,omitempty" tf:"zone,omitempty"`
}

type AwsCloudProviderObservation struct {
}

type AwsCloudProviderParameters struct {

	// +kubebuilder:validation:Optional
	Global []AwsCloudProviderGlobalParameters `json:"global,omitempty" tf:"global,omitempty"`

	// +kubebuilder:validation:Optional
	ServiceOverride []AwsCloudProviderServiceOverrideParameters `json:"serviceOverride,omitempty" tf:"service_override,omitempty"`
}

type AwsCloudProviderServiceOverrideObservation struct {
}

type AwsCloudProviderServiceOverrideParameters struct {

	// +kubebuilder:validation:Optional
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// +kubebuilder:validation:Required
	Service *string `json:"service" tf:"service,omitempty"`

	// +kubebuilder:validation:Optional
	SigningMethod *string `json:"signingMethod,omitempty" tf:"signing_method,omitempty"`

	// +kubebuilder:validation:Optional
	SigningName *string `json:"signingName,omitempty" tf:"signing_name,omitempty"`

	// +kubebuilder:validation:Optional
	SigningRegion *string `json:"signingRegion,omitempty" tf:"signing_region,omitempty"`

	// +kubebuilder:validation:Optional
	URL *string `json:"url,omitempty" tf:"url,omitempty"`
}

type AzureCloudConfigObservation struct {
}

type AzureCloudConfigParameters struct {

	// The password of the client certificate for an AAD application with RBAC access to talk to Azure RM APIs
	// +kubebuilder:validation:Optional
	AadClientCertPasswordSecretRef *v1.SecretKeySelector `json:"aadClientCertPasswordSecretRef,omitempty" tf:"-"`

	// The path of a client certificate for an AAD application with RBAC access to talk to Azure RM APIs
	// +kubebuilder:validation:Optional
	AadClientCertPath *string `json:"aadClientCertPath,omitempty" tf:"aad_client_cert_path,omitempty"`

	// The ClientID for an AAD application with RBAC access to talk to Azure RM APIs
	// +kubebuilder:validation:Required
	AadClientIDSecretRef v1.SecretKeySelector `json:"aadClientIdSecretRef" tf:"-"`

	// The ClientSecret for an AAD application with RBAC access to talk to Azure RM APIs
	// +kubebuilder:validation:Required
	AadClientSecretSecretRef v1.SecretKeySelector `json:"aadClientSecretSecretRef" tf:"-"`

	// The cloud environment identifier. Takes values from https://github.com/Azure/go-autorest/blob/ec5f4903f77ed9927ac95b19ab8e44ada64c1356/autorest/azure/environments.go#L13
	// +kubebuilder:validation:Optional
	Cloud *string `json:"cloud,omitempty" tf:"cloud,omitempty"`

	// Enable exponential backoff to manage resource request retries
	// +kubebuilder:validation:Optional
	CloudProviderBackoff *bool `json:"cloudProviderBackoff,omitempty" tf:"cloud_provider_backoff,omitempty"`

	// Backoff duration
	// +kubebuilder:validation:Optional
	CloudProviderBackoffDuration *float64 `json:"cloudProviderBackoffDuration,omitempty" tf:"cloud_provider_backoff_duration,omitempty"`

	// Backoff exponent
	// +kubebuilder:validation:Optional
	CloudProviderBackoffExponent *float64 `json:"cloudProviderBackoffExponent,omitempty" tf:"cloud_provider_backoff_exponent,omitempty"`

	// Backoff jitter
	// +kubebuilder:validation:Optional
	CloudProviderBackoffJitter *float64 `json:"cloudProviderBackoffJitter,omitempty" tf:"cloud_provider_backoff_jitter,omitempty"`

	// Backoff retry limit
	// +kubebuilder:validation:Optional
	CloudProviderBackoffRetries *float64 `json:"cloudProviderBackoffRetries,omitempty" tf:"cloud_provider_backoff_retries,omitempty"`

	// Enable rate limiting
	// +kubebuilder:validation:Optional
	CloudProviderRateLimit *bool `json:"cloudProviderRateLimit,omitempty" tf:"cloud_provider_rate_limit,omitempty"`

	// +kubebuilder:validation:Optional
	CloudProviderRateLimitBucket *float64 `json:"cloudProviderRateLimitBucket,omitempty" tf:"cloud_provider_rate_limit_bucket,omitempty"`

	// Rate limit QPS
	// +kubebuilder:validation:Optional
	CloudProviderRateLimitQPS *float64 `json:"cloudProviderRateLimitQps,omitempty" tf:"cloud_provider_rate_limit_qps,omitempty"`

	// Load balancer type (basic | standard). Must be standard for auto-scaling
	// +kubebuilder:validation:Optional
	LoadBalancerSku *string `json:"loadBalancerSku,omitempty" tf:"load_balancer_sku,omitempty"`

	// The location of the resource group that the cluster is deployed in
	// +kubebuilder:validation:Optional
	Location *string `json:"location,omitempty" tf:"location,omitempty"`

	// Maximum allowed LoadBalancer Rule Count is the limit enforced by Azure Load balancer
	// +kubebuilder:validation:Optional
	MaximumLoadBalancerRuleCount *float64 `json:"maximumLoadBalancerRuleCount,omitempty" tf:"maximum_load_balancer_rule_count,omitempty"`

	// The name of the availability set that should be used as the load balancer backendIf this is set, the Azure cloudprovider will only add nodes from that availability set to the loadbalancer backend pool. If this is not set, and multiple agent pools (availability sets) are used, thenthe cloudprovider will try to add all nodes to a single backend pool which is forbidden.In other words, if you use multiple agent pools (availability sets), you MUST set this field.
	// +kubebuilder:validation:Optional
	PrimaryAvailabilitySetName *string `json:"primaryAvailabilitySetName,omitempty" tf:"primary_availability_set_name,omitempty"`

	// The name of the scale set that should be used as the load balancer backend.If this is set, the Azure cloudprovider will only add nodes from that scale set to the loadbalancer backend pool. If this is not set, and multiple agent pools (scale sets) are used, thenthe cloudprovider will try to add all nodes to a single backend pool which is forbidden.In other words, if you use multiple agent pools (scale sets), you MUST set this field.
	// +kubebuilder:validation:Optional
	PrimaryScaleSetName *string `json:"primaryScaleSetName,omitempty" tf:"primary_scale_set_name,omitempty"`

	// The name of the resource group that the cluster is deployed in
	// +kubebuilder:validation:Optional
	ResourceGroup *string `json:"resourceGroup,omitempty" tf:"resource_group,omitempty"`

	// (Optional in 1.6) The name of the route table attached to the subnet that the cluster is deployed in
	// +kubebuilder:validation:Optional
	RouteTableName *string `json:"routeTableName,omitempty" tf:"route_table_name,omitempty"`

	// The name of the security group attached to the cluster's subnet
	// +kubebuilder:validation:Optional
	SecurityGroupName *string `json:"securityGroupName,omitempty" tf:"security_group_name,omitempty"`

	// The name of the Subnet that the cluster is deployed in
	// +kubebuilder:validation:Optional
	SubnetName *string `json:"subnetName,omitempty" tf:"subnet_name,omitempty"`

	// The ID of the Azure Subscription that the cluster is deployed in
	// +kubebuilder:validation:Required
	SubscriptionIDSecretRef v1.SecretKeySelector `json:"subscriptionIdSecretRef" tf:"-"`

	// The AAD Tenant ID for the Subscription that the cluster is deployed in
	// +kubebuilder:validation:Required
	TenantIDSecretRef v1.SecretKeySelector `json:"tenantIdSecretRef" tf:"-"`

	// Use instance metadata service where possible
	// +kubebuilder:validation:Optional
	UseInstanceMetadata *bool `json:"useInstanceMetadata,omitempty" tf:"use_instance_metadata,omitempty"`

	// Use managed service identity for the virtual machine to access Azure ARM APIs
	// +kubebuilder:validation:Optional
	UseManagedIdentityExtension *bool `json:"useManagedIdentityExtension,omitempty" tf:"use_managed_identity_extension,omitempty"`

	// The type of azure nodes. If not set, it will be default to standard.
	// +kubebuilder:validation:Optional
	VMType *string `json:"vmType,omitempty" tf:"vm_type,omitempty"`

	// The name of the VNet that the cluster is deployed in
	// +kubebuilder:validation:Optional
	VnetName *string `json:"vnetName,omitempty" tf:"vnet_name,omitempty"`

	// The name of the resource group that the Vnet is deployed in
	// +kubebuilder:validation:Optional
	VnetResourceGroup *string `json:"vnetResourceGroup,omitempty" tf:"vnet_resource_group,omitempty"`
}

type AzureCloudProviderObservation struct {
}

type AzureCloudProviderParameters struct {

	// The password of the client certificate for an AAD application with RBAC access to talk to Azure RM APIs
	// +kubebuilder:validation:Optional
	AadClientCertPasswordSecretRef *v1.SecretKeySelector `json:"aadClientCertPasswordSecretRef,omitempty" tf:"-"`

	// The path of a client certificate for an AAD application with RBAC access to talk to Azure RM APIs
	// +kubebuilder:validation:Optional
	AadClientCertPath *string `json:"aadClientCertPath,omitempty" tf:"aad_client_cert_path,omitempty"`

	// The ClientID for an AAD application with RBAC access to talk to Azure RM APIs
	// +kubebuilder:validation:Required
	AadClientIDSecretRef v1.SecretKeySelector `json:"aadClientIdSecretRef" tf:"-"`

	// The ClientSecret for an AAD application with RBAC access to talk to Azure RM APIs
	// +kubebuilder:validation:Required
	AadClientSecretSecretRef v1.SecretKeySelector `json:"aadClientSecretSecretRef" tf:"-"`

	// The cloud environment identifier. Takes values from https://github.com/Azure/go-autorest/blob/ec5f4903f77ed9927ac95b19ab8e44ada64c1356/autorest/azure/environments.go#L13
	// +kubebuilder:validation:Optional
	Cloud *string `json:"cloud,omitempty" tf:"cloud,omitempty"`

	// Enable exponential backoff to manage resource request retries
	// +kubebuilder:validation:Optional
	CloudProviderBackoff *bool `json:"cloudProviderBackoff,omitempty" tf:"cloud_provider_backoff,omitempty"`

	// Backoff duration
	// +kubebuilder:validation:Optional
	CloudProviderBackoffDuration *float64 `json:"cloudProviderBackoffDuration,omitempty" tf:"cloud_provider_backoff_duration,omitempty"`

	// Backoff exponent
	// +kubebuilder:validation:Optional
	CloudProviderBackoffExponent *float64 `json:"cloudProviderBackoffExponent,omitempty" tf:"cloud_provider_backoff_exponent,omitempty"`

	// Backoff jitter
	// +kubebuilder:validation:Optional
	CloudProviderBackoffJitter *float64 `json:"cloudProviderBackoffJitter,omitempty" tf:"cloud_provider_backoff_jitter,omitempty"`

	// Backoff retry limit
	// +kubebuilder:validation:Optional
	CloudProviderBackoffRetries *float64 `json:"cloudProviderBackoffRetries,omitempty" tf:"cloud_provider_backoff_retries,omitempty"`

	// Enable rate limiting
	// +kubebuilder:validation:Optional
	CloudProviderRateLimit *bool `json:"cloudProviderRateLimit,omitempty" tf:"cloud_provider_rate_limit,omitempty"`

	// +kubebuilder:validation:Optional
	CloudProviderRateLimitBucket *float64 `json:"cloudProviderRateLimitBucket,omitempty" tf:"cloud_provider_rate_limit_bucket,omitempty"`

	// Rate limit QPS
	// +kubebuilder:validation:Optional
	CloudProviderRateLimitQPS *float64 `json:"cloudProviderRateLimitQps,omitempty" tf:"cloud_provider_rate_limit_qps,omitempty"`

	// Load balancer type (basic | standard). Must be standard for auto-scaling
	// +kubebuilder:validation:Optional
	LoadBalancerSku *string `json:"loadBalancerSku,omitempty" tf:"load_balancer_sku,omitempty"`

	// The location of the resource group that the cluster is deployed in
	// +kubebuilder:validation:Optional
	Location *string `json:"location,omitempty" tf:"location,omitempty"`

	// Maximum allowed LoadBalancer Rule Count is the limit enforced by Azure Load balancer
	// +kubebuilder:validation:Optional
	MaximumLoadBalancerRuleCount *float64 `json:"maximumLoadBalancerRuleCount,omitempty" tf:"maximum_load_balancer_rule_count,omitempty"`

	// The name of the availability set that should be used as the load balancer backendIf this is set, the Azure cloudprovider will only add nodes from that availability set to the loadbalancer backend pool. If this is not set, and multiple agent pools (availability sets) are used, thenthe cloudprovider will try to add all nodes to a single backend pool which is forbidden.In other words, if you use multiple agent pools (availability sets), you MUST set this field.
	// +kubebuilder:validation:Optional
	PrimaryAvailabilitySetName *string `json:"primaryAvailabilitySetName,omitempty" tf:"primary_availability_set_name,omitempty"`

	// The name of the scale set that should be used as the load balancer backend.If this is set, the Azure cloudprovider will only add nodes from that scale set to the loadbalancer backend pool. If this is not set, and multiple agent pools (scale sets) are used, thenthe cloudprovider will try to add all nodes to a single backend pool which is forbidden.In other words, if you use multiple agent pools (scale sets), you MUST set this field.
	// +kubebuilder:validation:Optional
	PrimaryScaleSetName *string `json:"primaryScaleSetName,omitempty" tf:"primary_scale_set_name,omitempty"`

	// The name of the resource group that the cluster is deployed in
	// +kubebuilder:validation:Optional
	ResourceGroup *string `json:"resourceGroup,omitempty" tf:"resource_group,omitempty"`

	// (Optional in 1.6) The name of the route table attached to the subnet that the cluster is deployed in
	// +kubebuilder:validation:Optional
	RouteTableName *string `json:"routeTableName,omitempty" tf:"route_table_name,omitempty"`

	// The name of the security group attached to the cluster's subnet
	// +kubebuilder:validation:Optional
	SecurityGroupName *string `json:"securityGroupName,omitempty" tf:"security_group_name,omitempty"`

	// The name of the Subnet that the cluster is deployed in
	// +kubebuilder:validation:Optional
	SubnetName *string `json:"subnetName,omitempty" tf:"subnet_name,omitempty"`

	// The ID of the Azure Subscription that the cluster is deployed in
	// +kubebuilder:validation:Required
	SubscriptionIDSecretRef v1.SecretKeySelector `json:"subscriptionIdSecretRef" tf:"-"`

	// The AAD Tenant ID for the Subscription that the cluster is deployed in
	// +kubebuilder:validation:Required
	TenantIDSecretRef v1.SecretKeySelector `json:"tenantIdSecretRef" tf:"-"`

	// Use instance metadata service where possible
	// +kubebuilder:validation:Optional
	UseInstanceMetadata *bool `json:"useInstanceMetadata,omitempty" tf:"use_instance_metadata,omitempty"`

	// Use managed service identity for the virtual machine to access Azure ARM APIs
	// +kubebuilder:validation:Optional
	UseManagedIdentityExtension *bool `json:"useManagedIdentityExtension,omitempty" tf:"use_managed_identity_extension,omitempty"`

	// The type of azure nodes. If not set, it will be default to standard.
	// +kubebuilder:validation:Optional
	VMType *string `json:"vmType,omitempty" tf:"vm_type,omitempty"`

	// The name of the VNet that the cluster is deployed in
	// +kubebuilder:validation:Optional
	VnetName *string `json:"vnetName,omitempty" tf:"vnet_name,omitempty"`

	// The name of the resource group that the Vnet is deployed in
	// +kubebuilder:validation:Optional
	VnetResourceGroup *string `json:"vnetResourceGroup,omitempty" tf:"vnet_resource_group,omitempty"`
}

type BackupConfigObservation struct {
}

type BackupConfigParameters struct {

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// +kubebuilder:validation:Optional
	IntervalHours *float64 `json:"intervalHours,omitempty" tf:"interval_hours,omitempty"`

	// +kubebuilder:validation:Optional
	Retention *float64 `json:"retention,omitempty" tf:"retention,omitempty"`

	// +kubebuilder:validation:Optional
	S3BackupConfig []S3BackupConfigParameters `json:"s3BackupConfig,omitempty" tf:"s3_backup_config,omitempty"`

	// +kubebuilder:validation:Optional
	SafeTimestamp *bool `json:"safeTimestamp,omitempty" tf:"safe_timestamp,omitempty"`

	// +kubebuilder:validation:Optional
	Timeout *float64 `json:"timeout,omitempty" tf:"timeout,omitempty"`
}

type BackupConfigS3BackupConfigObservation struct {
}

type BackupConfigS3BackupConfigParameters struct {

	// +kubebuilder:validation:Optional
	AccessKeySecretRef *v1.SecretKeySelector `json:"accessKeySecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	BucketName *string `json:"bucketName,omitempty" tf:"bucket_name,omitempty"`

	// +kubebuilder:validation:Optional
	CustomCA *string `json:"customCa,omitempty" tf:"custom_ca,omitempty"`

	// +kubebuilder:validation:Optional
	Endpoint *string `json:"endpoint,omitempty" tf:"endpoint,omitempty"`

	// +kubebuilder:validation:Optional
	Folder *string `json:"folder,omitempty" tf:"folder,omitempty"`

	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// +kubebuilder:validation:Optional
	SecretKeySecretRef *v1.SecretKeySelector `json:"secretKeySecretRef,omitempty" tf:"-"`
}

type BastionHostObservation struct {
}

type BastionHostParameters struct {

	// Address of Bastion Host
	// +kubebuilder:validation:Required
	Address *string `json:"address" tf:"address,omitempty"`

	// Ignore proxy env vars at Bastion Host?
	// +kubebuilder:validation:Optional
	IgnoreProxyEnvVars *bool `json:"ignoreProxyEnvVars,omitempty" tf:"ignore_proxy_env_vars,omitempty"`

	// SSH Port of Bastion Host
	// +kubebuilder:validation:Optional
	Port *string `json:"port,omitempty" tf:"port,omitempty"`

	// SSH Agent Auth enable
	// +kubebuilder:validation:Optional
	SSHAgentAuth *bool `json:"sshAgentAuth,omitempty" tf:"ssh_agent_auth,omitempty"`

	// SSH Certificate Key Path
	// +kubebuilder:validation:Optional
	SSHCertPath *string `json:"sshCertPath,omitempty" tf:"ssh_cert_path,omitempty"`

	// SSH Certificate Key
	// +kubebuilder:validation:Optional
	SSHCertSecretRef *v1.SecretKeySelector `json:"sshCertSecretRef,omitempty" tf:"-"`

	// SSH Private Key Path
	// +kubebuilder:validation:Optional
	SSHKeyPath *string `json:"sshKeyPath,omitempty" tf:"ssh_key_path,omitempty"`

	// SSH Private Key
	// +kubebuilder:validation:Optional
	SSHKeySecretRef *v1.SecretKeySelector `json:"sshKeySecretRef,omitempty" tf:"-"`

	// SSH User to Bastion Host
	// +kubebuilder:validation:Required
	User *string `json:"user" tf:"user,omitempty"`
}

type BlockStorageObservation struct {
}

type BlockStorageParameters struct {

	// +kubebuilder:validation:Optional
	BsVersion *string `json:"bsVersion,omitempty" tf:"bs_version,omitempty"`

	// +kubebuilder:validation:Optional
	IgnoreVolumeAz *bool `json:"ignoreVolumeAz,omitempty" tf:"ignore_volume_az,omitempty"`

	// +kubebuilder:validation:Optional
	TrustDevicePath *bool `json:"trustDevicePath,omitempty" tf:"trust_device_path,omitempty"`
}

type CalicoNetworkProviderObservation struct {
}

type CalicoNetworkProviderParameters struct {

	// +kubebuilder:validation:Optional
	CloudProvider *string `json:"cloudProvider,omitempty" tf:"cloud_provider,omitempty"`
}

type CanalNetworkProviderObservation struct {
}

type CanalNetworkProviderParameters struct {

	// +kubebuilder:validation:Optional
	Iface *string `json:"iface,omitempty" tf:"iface,omitempty"`
}

type CertificatesObservation struct {
	Certificate *string `json:"certificate,omitempty" tf:"certificate,omitempty"`

	CommonName *string `json:"commonName,omitempty" tf:"common_name,omitempty"`

	Config *string `json:"config,omitempty" tf:"config,omitempty"`

	ConfigEnvName *string `json:"configEnvName,omitempty" tf:"config_env_name,omitempty"`

	ConfigPath *string `json:"configPath,omitempty" tf:"config_path,omitempty"`

	EnvName *string `json:"envName,omitempty" tf:"env_name,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	KeyEnvName *string `json:"keyEnvName,omitempty" tf:"key_env_name,omitempty"`

	KeyPath *string `json:"keyPath,omitempty" tf:"key_path,omitempty"`

	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	OuName *string `json:"ouName,omitempty" tf:"ou_name,omitempty"`

	Path *string `json:"path,omitempty" tf:"path,omitempty"`
}

type CertificatesParameters struct {
}

type CloudProviderObservation struct {
}

type CloudProviderParameters struct {

	// +kubebuilder:validation:Optional
	AwsCloudConfig []AwsCloudConfigParameters `json:"awsCloudConfig,omitempty" tf:"aws_cloud_config,omitempty"`

	// AWS Cloud Provider config
	// +kubebuilder:validation:Optional
	AwsCloudProvider []AwsCloudProviderParameters `json:"awsCloudProvider,omitempty" tf:"aws_cloud_provider,omitempty"`

	// +kubebuilder:validation:Optional
	AzureCloudConfig []AzureCloudConfigParameters `json:"azureCloudConfig,omitempty" tf:"azure_cloud_config,omitempty"`

	// Azure Cloud Provider config
	// +kubebuilder:validation:Optional
	AzureCloudProvider []AzureCloudProviderParameters `json:"azureCloudProvider,omitempty" tf:"azure_cloud_provider,omitempty"`

	// +kubebuilder:validation:Optional
	CustomCloudConfig *string `json:"customCloudConfig,omitempty" tf:"custom_cloud_config,omitempty"`

	// Custom Cloud Provider config
	// +kubebuilder:validation:Optional
	CustomCloudProvider *string `json:"customCloudProvider,omitempty" tf:"custom_cloud_provider,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	OpenstackCloudConfig []OpenstackCloudConfigParameters `json:"openstackCloudConfig,omitempty" tf:"openstack_cloud_config,omitempty"`

	// Openstack Cloud Provider config
	// +kubebuilder:validation:Optional
	OpenstackCloudProvider []OpenstackCloudProviderParameters `json:"openstackCloudProvider,omitempty" tf:"openstack_cloud_provider,omitempty"`

	// +kubebuilder:validation:Optional
	VsphereCloudConfig []VsphereCloudConfigParameters `json:"vsphereCloudConfig,omitempty" tf:"vsphere_cloud_config,omitempty"`

	// Vsphere Cloud Provider config
	// +kubebuilder:validation:Optional
	VsphereCloudProvider []VsphereCloudProviderParameters `json:"vsphereCloudProvider,omitempty" tf:"vsphere_cloud_provider,omitempty"`
}

type ClusterNetworkObservation struct {
}

type ClusterNetworkParameters struct {

	// Aci network provider config
	// +kubebuilder:validation:Optional
	AciNetworkProvider []AciNetworkProviderParameters `json:"aciNetworkProvider,omitempty" tf:"aci_network_provider,omitempty"`

	// Calico network provider config
	// +kubebuilder:validation:Optional
	CalicoNetworkProvider []CalicoNetworkProviderParameters `json:"calicoNetworkProvider,omitempty" tf:"calico_network_provider,omitempty"`

	// Canal network provider config
	// +kubebuilder:validation:Optional
	CanalNetworkProvider []CanalNetworkProviderParameters `json:"canalNetworkProvider,omitempty" tf:"canal_network_provider,omitempty"`

	// Flannel network provider config
	// +kubebuilder:validation:Optional
	FlannelNetworkProvider []FlannelNetworkProviderParameters `json:"flannelNetworkProvider,omitempty" tf:"flannel_network_provider,omitempty"`

	// Network provider MTU
	// +kubebuilder:validation:Optional
	Mtu *float64 `json:"mtu,omitempty" tf:"mtu,omitempty"`

	// Network provider options
	// +kubebuilder:validation:Optional
	Options map[string]*string `json:"options,omitempty" tf:"options,omitempty"`

	// Network provider plugin
	// +kubebuilder:validation:Optional
	Plugin *string `json:"plugin,omitempty" tf:"plugin,omitempty"`

	// Weave network provider config
	// +kubebuilder:validation:Optional
	WeaveNetworkProvider []WeaveNetworkProviderParameters `json:"weaveNetworkProvider,omitempty" tf:"weave_network_provider,omitempty"`
}

type ClusterObservation struct {
	APIServerURL *string `json:"apiServerUrl,omitempty" tf:"api_server_url,omitempty"`

	ClusterCidr *string `json:"clusterCidr,omitempty" tf:"cluster_cidr,omitempty"`

	ClusterDNSServer *string `json:"clusterDnsServer,omitempty" tf:"cluster_dns_server,omitempty"`

	ClusterDomain *string `json:"clusterDomain,omitempty" tf:"cluster_domain,omitempty"`

	ControlPlaneHosts []ControlPlaneHostsObservation `json:"controlPlaneHosts,omitempty" tf:"control_plane_hosts,omitempty"`

	EtcdHosts []EtcdHostsObservation `json:"etcdHosts,omitempty" tf:"etcd_hosts,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	InactiveHosts []InactiveHostsObservation `json:"inactiveHosts,omitempty" tf:"inactive_hosts,omitempty"`

	KubeAdminUser *string `json:"kubeAdminUser,omitempty" tf:"kube_admin_user,omitempty"`

	RunningSystemImages []RunningSystemImagesObservation `json:"runningSystemImages,omitempty" tf:"running_system_images,omitempty"`

	WorkerHosts []WorkerHostsObservation `json:"workerHosts,omitempty" tf:"worker_hosts,omitempty"`
}

type ClusterParameters struct {

	// RKE k8s cluster addon deployment timeout in seconds for status check
	// +kubebuilder:validation:Optional
	AddonJobTimeout *float64 `json:"addonJobTimeout,omitempty" tf:"addon_job_timeout,omitempty"`

	// RKE k8s cluster user addons YAML manifest to be deployed
	// +kubebuilder:validation:Optional
	Addons *string `json:"addons,omitempty" tf:"addons,omitempty"`

	// RKE k8s cluster user addons YAML manifest urls or paths to be deployed
	// +kubebuilder:validation:Optional
	AddonsInclude []*string `json:"addonsInclude,omitempty" tf:"addons_include,omitempty"`

	// RKE k8s cluster authentication configuration
	// +kubebuilder:validation:Optional
	Authentication []AuthenticationParameters `json:"authentication,omitempty" tf:"authentication,omitempty"`

	// RKE k8s cluster authorization mode configuration
	// +kubebuilder:validation:Optional
	Authorization []AuthorizationParameters `json:"authorization,omitempty" tf:"authorization,omitempty"`

	// RKE k8s cluster bastion Host configuration
	// +kubebuilder:validation:Optional
	BastionHost []BastionHostParameters `json:"bastionHost,omitempty" tf:"bastion_host,omitempty"`

	// Specify a certificate dir path
	// +kubebuilder:validation:Optional
	CertDir *string `json:"certDir,omitempty" tf:"cert_dir,omitempty"`

	// RKE k8s cluster cloud provider configuration
	// +kubebuilder:validation:Optional
	CloudProvider []CloudProviderParameters `json:"cloudProvider,omitempty" tf:"cloud_provider,omitempty"`

	// RKE k8s cluster config yaml
	// +kubebuilder:validation:Optional
	ClusterYamlSecretRef *v1.SecretKeySelector `json:"clusterYamlSecretRef,omitempty" tf:"-"`

	// Use custom certificates from a cert dir
	// +kubebuilder:validation:Optional
	CustomCerts *bool `json:"customCerts,omitempty" tf:"custom_certs,omitempty"`

	// RKE k8s cluster DNS Config
	// +kubebuilder:validation:Optional
	DNS []DNSParameters `json:"dns,omitempty" tf:"dns,omitempty"`

	// RKE k8s cluster delay on creation
	// +kubebuilder:validation:Optional
	DelayOnCreation *float64 `json:"delayOnCreation,omitempty" tf:"delay_on_creation,omitempty"`

	// RKE k8s cluster dind (experimental)
	// +kubebuilder:validation:Optional
	Dind *bool `json:"dind,omitempty" tf:"dind,omitempty"`

	// RKE k8s cluster dind storage driver (experimental)
	// +kubebuilder:validation:Optional
	DindDNSServer *string `json:"dindDnsServer,omitempty" tf:"dind_dns_server,omitempty"`

	// RKE k8s cluster dind storage driver (experimental)
	// +kubebuilder:validation:Optional
	DindStorageDriver *string `json:"dindStorageDriver,omitempty" tf:"dind_storage_driver,omitempty"`

	// Enable/Disable RKE k8s cluster port checking
	// +kubebuilder:validation:Optional
	DisablePortCheck *bool `json:"disablePortCheck,omitempty" tf:"disable_port_check,omitempty"`

	// Enable/Disable RKE k8s cluster strict docker version checking
	// +kubebuilder:validation:Optional
	IgnoreDockerVersion *bool `json:"ignoreDockerVersion,omitempty" tf:"ignore_docker_version,omitempty"`

	// RKE k8s cluster ingress controller configuration
	// +kubebuilder:validation:Optional
	Ingress []IngressParameters `json:"ingress,omitempty" tf:"ingress,omitempty"`

	// K8s version to deploy (if kubernetes image is specified, image version takes precedence)
	// +kubebuilder:validation:Optional
	KubernetesVersion *string `json:"kubernetesVersion,omitempty" tf:"kubernetes_version,omitempty"`

	// RKE k8s cluster monitoring Config
	// +kubebuilder:validation:Optional
	Monitoring []MonitoringParameters `json:"monitoring,omitempty" tf:"monitoring,omitempty"`

	// RKE k8s cluster network configuration
	// +kubebuilder:validation:Optional
	Network []ClusterNetworkParameters `json:"network,omitempty" tf:"network,omitempty"`

	// RKE k8s cluster nodes
	// +kubebuilder:validation:Optional
	Nodes []NodesParameters `json:"nodes,omitempty" tf:"nodes,omitempty"`

	// +kubebuilder:validation:Optional
	NodesConf []*string `json:"nodesConf,omitempty" tf:"nodes_conf,omitempty"`

	// RKE k8s directory path
	// +kubebuilder:validation:Optional
	PrefixPath *string `json:"prefixPath,omitempty" tf:"prefix_path,omitempty"`

	// RKE k8s cluster private docker registries
	// +kubebuilder:validation:Optional
	PrivateRegistries []PrivateRegistriesParameters `json:"privateRegistries,omitempty" tf:"private_registries,omitempty"`

	// RKE k8s cluster restore configuration
	// +kubebuilder:validation:Optional
	Restore []RestoreParameters `json:"restore,omitempty" tf:"restore,omitempty"`

	// RKE k8s cluster rotate certificates configuration
	// +kubebuilder:validation:Optional
	RotateCertificates []RotateCertificatesParameters `json:"rotateCertificates,omitempty" tf:"rotate_certificates,omitempty"`

	// SSH Agent Auth enable
	// +kubebuilder:validation:Optional
	SSHAgentAuth *bool `json:"sshAgentAuth,omitempty" tf:"ssh_agent_auth,omitempty"`

	// SSH Certificate Path
	// +kubebuilder:validation:Optional
	SSHCertPath *string `json:"sshCertPath,omitempty" tf:"ssh_cert_path,omitempty"`

	// SSH Private Key Path
	// +kubebuilder:validation:Optional
	SSHKeyPath *string `json:"sshKeyPath,omitempty" tf:"ssh_key_path,omitempty"`

	// RKE k8s cluster services
	// +kubebuilder:validation:Optional
	Services []ServicesParameters `json:"services,omitempty" tf:"services,omitempty"`

	// +kubebuilder:validation:Optional
	ServicesEtcd []ServicesEtcdParameters `json:"servicesEtcd,omitempty" tf:"services_etcd,omitempty"`

	// +kubebuilder:validation:Optional
	ServicesKubeAPI []ServicesKubeAPIParameters `json:"servicesKubeApi,omitempty" tf:"services_kube_api,omitempty"`

	// +kubebuilder:validation:Optional
	ServicesKubeController []ServicesKubeControllerParameters `json:"servicesKubeController,omitempty" tf:"services_kube_controller,omitempty"`

	// +kubebuilder:validation:Optional
	ServicesKubelet []ServicesKubeletParameters `json:"servicesKubelet,omitempty" tf:"services_kubelet,omitempty"`

	// +kubebuilder:validation:Optional
	ServicesKubeproxy []ServicesKubeproxyParameters `json:"servicesKubeproxy,omitempty" tf:"services_kubeproxy,omitempty"`

	// +kubebuilder:validation:Optional
	ServicesScheduler []ServicesSchedulerParameters `json:"servicesScheduler,omitempty" tf:"services_scheduler,omitempty"`

	// RKE k8s cluster system images list
	// +kubebuilder:validation:Optional
	SystemImages []SystemImagesParameters `json:"systemImages,omitempty" tf:"system_images,omitempty"`

	// Skip idempotent deployment of control and etcd plane
	// +kubebuilder:validation:Optional
	UpdateOnly *bool `json:"updateOnly,omitempty" tf:"update_only,omitempty"`

	// RKE k8s cluster upgrade strategy
	// +kubebuilder:validation:Optional
	UpgradeStrategy []UpgradeStrategyParameters `json:"upgradeStrategy,omitempty" tf:"upgrade_strategy,omitempty"`
}

type ConfigurationObservation struct {
}

type ConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	Format *string `json:"format,omitempty" tf:"format,omitempty"`

	// +kubebuilder:validation:Optional
	MaxAge *float64 `json:"maxAge,omitempty" tf:"max_age,omitempty"`

	// +kubebuilder:validation:Optional
	MaxBackup *float64 `json:"maxBackup,omitempty" tf:"max_backup,omitempty"`

	// +kubebuilder:validation:Optional
	MaxSize *float64 `json:"maxSize,omitempty" tf:"max_size,omitempty"`

	// +kubebuilder:validation:Optional
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// +kubebuilder:validation:Optional
	Policy *string `json:"policy,omitempty" tf:"policy,omitempty"`
}

type ControlPlaneHostsObservation struct {
	Address *string `json:"address,omitempty" tf:"address,omitempty"`

	NodeName *string `json:"nodeName,omitempty" tf:"node_name,omitempty"`
}

type ControlPlaneHostsParameters struct {
}

type DNSObservation struct {
}

type DNSParameters struct {

	// NodeSelector key pair
	// +kubebuilder:validation:Optional
	NodeSelector map[string]*string `json:"nodeSelector,omitempty" tf:"node_selector,omitempty"`

	// Nodelocal dns
	// +kubebuilder:validation:Optional
	Nodelocal []NodelocalParameters `json:"nodelocal,omitempty" tf:"nodelocal,omitempty"`

	// DNS provider
	// +kubebuilder:validation:Optional
	Provider *string `json:"provider,omitempty" tf:"provider,omitempty"`

	// ReverseCIDRs
	// +kubebuilder:validation:Optional
	ReverseCidrs []*string `json:"reverseCidrs,omitempty" tf:"reverse_cidrs,omitempty"`

	// Upstream nameservers
	// +kubebuilder:validation:Optional
	UpstreamNameservers []*string `json:"upstreamNameservers,omitempty" tf:"upstream_nameservers,omitempty"`
}

type DiskObservation struct {
}

type DiskParameters struct {

	// +kubebuilder:validation:Optional
	ScsiControllerType *string `json:"scsiControllerType,omitempty" tf:"scsi_controller_type,omitempty"`
}

type DrainInputObservation struct {
}

type DrainInputParameters struct {

	// +kubebuilder:validation:Optional
	DeleteLocalData *bool `json:"deleteLocalData,omitempty" tf:"delete_local_data,omitempty"`

	// +kubebuilder:validation:Optional
	Force *bool `json:"force,omitempty" tf:"force,omitempty"`

	// +kubebuilder:validation:Optional
	GracePeriod *float64 `json:"gracePeriod,omitempty" tf:"grace_period,omitempty"`

	// +kubebuilder:validation:Optional
	IgnoreDaemonSets *bool `json:"ignoreDaemonSets,omitempty" tf:"ignore_daemon_sets,omitempty"`

	// +kubebuilder:validation:Optional
	Timeout *float64 `json:"timeout,omitempty" tf:"timeout,omitempty"`
}

type EtcdHostsObservation struct {
	Address *string `json:"address,omitempty" tf:"address,omitempty"`

	NodeName *string `json:"nodeName,omitempty" tf:"node_name,omitempty"`
}

type EtcdHostsParameters struct {
}

type EtcdObservation struct {
}

type EtcdParameters struct {

	// +kubebuilder:validation:Optional
	BackupConfig []BackupConfigParameters `json:"backupConfig,omitempty" tf:"backup_config,omitempty"`

	// +kubebuilder:validation:Optional
	CACertSecretRef *v1.SecretKeySelector `json:"caCertSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	CertSecretRef *v1.SecretKeySelector `json:"certSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	Creation *string `json:"creation,omitempty" tf:"creation,omitempty"`

	// +kubebuilder:validation:Optional
	ExternalUrls []*string `json:"externalUrls,omitempty" tf:"external_urls,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraArgs map[string]*string `json:"extraArgs,omitempty" tf:"extra_args,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraBinds []*string `json:"extraBinds,omitempty" tf:"extra_binds,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraEnv []*string `json:"extraEnv,omitempty" tf:"extra_env,omitempty"`

	// +kubebuilder:validation:Optional
	GID *float64 `json:"gid,omitempty" tf:"gid,omitempty"`

	// +kubebuilder:validation:Optional
	Image *string `json:"image,omitempty" tf:"image,omitempty"`

	// +kubebuilder:validation:Optional
	KeySecretRef *v1.SecretKeySelector `json:"keySecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// +kubebuilder:validation:Optional
	Retention *string `json:"retention,omitempty" tf:"retention,omitempty"`

	// +kubebuilder:validation:Optional
	Snapshot *bool `json:"snapshot,omitempty" tf:"snapshot,omitempty"`

	// +kubebuilder:validation:Optional
	UID *float64 `json:"uid,omitempty" tf:"uid,omitempty"`
}

type EventRateLimitObservation struct {
}

type EventRateLimitParameters struct {

	// +kubebuilder:validation:Optional
	Configuration *string `json:"configuration,omitempty" tf:"configuration,omitempty"`

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type FlannelNetworkProviderObservation struct {
}

type FlannelNetworkProviderParameters struct {

	// +kubebuilder:validation:Optional
	Iface *string `json:"iface,omitempty" tf:"iface,omitempty"`
}

type GlobalObservation struct {
}

type GlobalParameters struct {

	// Disables the automatic ingress creation
	// +kubebuilder:validation:Optional
	DisableSecurityGroupIngress *bool `json:"disableSecurityGroupIngress,omitempty" tf:"disable_security_group_ingress,omitempty"`

	// Setting this to true will disable the check and provide a warning that the check was skipped
	// +kubebuilder:validation:Optional
	DisableStrictZoneCheck *bool `json:"disableStrictZoneCheck,omitempty" tf:"disable_strict_zone_check,omitempty"`

	// Use these ELB security groups instead create new
	// +kubebuilder:validation:Optional
	ELBSecurityGroup *string `json:"elbSecurityGroup,omitempty" tf:"elb_security_group,omitempty"`

	// The cluster id we'll use to identify our cluster resources
	// +kubebuilder:validation:Optional
	KubernetesClusterID *string `json:"kubernetesClusterId,omitempty" tf:"kubernetes_cluster_id,omitempty"`

	// Legacy cluster id we'll use to identify our cluster resources
	// +kubebuilder:validation:Optional
	KubernetesClusterTag *string `json:"kubernetesClusterTag,omitempty" tf:"kubernetes_cluster_tag,omitempty"`

	// IAM role to assume when interaction with AWS APIs
	// +kubebuilder:validation:Optional
	RoleArn *string `json:"roleArn,omitempty" tf:"role_arn,omitempty"`

	// Enables using a specific RouteTable
	// +kubebuilder:validation:Optional
	RouteTableID *string `json:"routeTableId,omitempty" tf:"route_table_id,omitempty"`

	// Enables using a specific subnet to use for ELB's
	// +kubebuilder:validation:Optional
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`

	// The AWS VPC flag enables the possibility to run the master components on a different aws account, on a different cloud provider or on-premises. If the flag is set also the KubernetesClusterTag must be provided
	// +kubebuilder:validation:Optional
	VPC *string `json:"vpc,omitempty" tf:"vpc,omitempty"`

	// The AWS zone
	// +kubebuilder:validation:Optional
	Zone *string `json:"zone,omitempty" tf:"zone,omitempty"`
}

type InactiveHostsObservation struct {
	Address *string `json:"address,omitempty" tf:"address,omitempty"`

	NodeName *string `json:"nodeName,omitempty" tf:"node_name,omitempty"`
}

type InactiveHostsParameters struct {
}

type IngressObservation struct {
}

type IngressParameters struct {

	// Ingress controller dns policy
	// +kubebuilder:validation:Optional
	DNSPolicy *string `json:"dnsPolicy,omitempty" tf:"dns_policy,omitempty"`

	// Ingress Default Backend
	// +kubebuilder:validation:Optional
	DefaultBackend *bool `json:"defaultBackend,omitempty" tf:"default_backend,omitempty"`

	// Extra arguments for the ingress controller
	// +kubebuilder:validation:Optional
	ExtraArgs map[string]*string `json:"extraArgs,omitempty" tf:"extra_args,omitempty"`

	// Ingress controller http port
	// +kubebuilder:validation:Optional
	HTTPPort *float64 `json:"httpPort,omitempty" tf:"http_port,omitempty"`

	// Ingress controller https port
	// +kubebuilder:validation:Optional
	HTTPSPort *float64 `json:"httpsPort,omitempty" tf:"https_port,omitempty"`

	// Ingress controller network mode
	// +kubebuilder:validation:Optional
	NetworkMode *string `json:"networkMode,omitempty" tf:"network_mode,omitempty"`

	// Node selector key pair
	// +kubebuilder:validation:Optional
	NodeSelector map[string]*string `json:"nodeSelector,omitempty" tf:"node_selector,omitempty"`

	// Ingress controller options
	// +kubebuilder:validation:Optional
	Options map[string]*string `json:"options,omitempty" tf:"options,omitempty"`

	// Ingress controller provider
	// +kubebuilder:validation:Optional
	Provider *string `json:"provider,omitempty" tf:"provider,omitempty"`
}

type KubeAPIObservation struct {
}

type KubeAPIParameters struct {

	// Enable/Disable AlwaysPullImages admissions plugin
	// +kubebuilder:validation:Optional
	AlwaysPullImages *bool `json:"alwaysPullImages,omitempty" tf:"always_pull_images,omitempty"`

	// +kubebuilder:validation:Optional
	AuditLog []AuditLogParameters `json:"auditLog,omitempty" tf:"audit_log,omitempty"`

	// +kubebuilder:validation:Optional
	EventRateLimit []EventRateLimitParameters `json:"eventRateLimit,omitempty" tf:"event_rate_limit,omitempty"`

	// Extra arguments that are added to the kube-api services
	// +kubebuilder:validation:Optional
	ExtraArgs map[string]*string `json:"extraArgs,omitempty" tf:"extra_args,omitempty"`

	// Extra binds added to the controlplane nodes
	// +kubebuilder:validation:Optional
	ExtraBinds []*string `json:"extraBinds,omitempty" tf:"extra_binds,omitempty"`

	// Extra env added to the controlplane nodes
	// +kubebuilder:validation:Optional
	ExtraEnv []*string `json:"extraEnv,omitempty" tf:"extra_env,omitempty"`

	// +kubebuilder:validation:Optional
	Image *string `json:"image,omitempty" tf:"image,omitempty"`

	// Enabled/Disable PodSecurityPolicy
	// +kubebuilder:validation:Optional
	PodSecurityPolicy *bool `json:"podSecurityPolicy,omitempty" tf:"pod_security_policy,omitempty"`

	// +kubebuilder:validation:Optional
	SecretsEncryptionConfig []SecretsEncryptionConfigParameters `json:"secretsEncryptionConfig,omitempty" tf:"secrets_encryption_config,omitempty"`

	// Virtual IP range that will be used by Kubernetes services
	// +kubebuilder:validation:Optional
	ServiceClusterIPRange *string `json:"serviceClusterIpRange,omitempty" tf:"service_cluster_ip_range,omitempty"`

	// Port range for services defined with NodePort type
	// +kubebuilder:validation:Optional
	ServiceNodePortRange *string `json:"serviceNodePortRange,omitempty" tf:"service_node_port_range,omitempty"`
}

type KubeControllerObservation struct {
}

type KubeControllerParameters struct {

	// CIDR Range for Pods in cluster
	// +kubebuilder:validation:Optional
	ClusterCidr *string `json:"clusterCidr,omitempty" tf:"cluster_cidr,omitempty"`

	// Extra arguments that are added to the kube-controller service
	// +kubebuilder:validation:Optional
	ExtraArgs map[string]*string `json:"extraArgs,omitempty" tf:"extra_args,omitempty"`

	// Extra binds added to the controlplane nodes
	// +kubebuilder:validation:Optional
	ExtraBinds []*string `json:"extraBinds,omitempty" tf:"extra_binds,omitempty"`

	// Extra env added to the controlplane nodes
	// +kubebuilder:validation:Optional
	ExtraEnv []*string `json:"extraEnv,omitempty" tf:"extra_env,omitempty"`

	// Docker image of the kube-controller service
	// +kubebuilder:validation:Optional
	Image *string `json:"image,omitempty" tf:"image,omitempty"`

	// Virtual IP range that will be used by Kubernetes services
	// +kubebuilder:validation:Optional
	ServiceClusterIPRange *string `json:"serviceClusterIpRange,omitempty" tf:"service_cluster_ip_range,omitempty"`
}

type KubeletObservation struct {
}

type KubeletParameters struct {

	// Cluster DNS service ip
	// +kubebuilder:validation:Optional
	ClusterDNSServer *string `json:"clusterDnsServer,omitempty" tf:"cluster_dns_server,omitempty"`

	// Domain of the cluster
	// +kubebuilder:validation:Optional
	ClusterDomain *string `json:"clusterDomain,omitempty" tf:"cluster_domain,omitempty"`

	// Extra arguments that are added to the kubelet services
	// +kubebuilder:validation:Optional
	ExtraArgs map[string]*string `json:"extraArgs,omitempty" tf:"extra_args,omitempty"`

	// Extra binds added to the worker nodes
	// +kubebuilder:validation:Optional
	ExtraBinds []*string `json:"extraBinds,omitempty" tf:"extra_binds,omitempty"`

	// Extra env added to the nodes
	// +kubebuilder:validation:Optional
	ExtraEnv []*string `json:"extraEnv,omitempty" tf:"extra_env,omitempty"`

	// Fail if swap is enabled
	// +kubebuilder:validation:Optional
	FailSwapOn *bool `json:"failSwapOn,omitempty" tf:"fail_swap_on,omitempty"`

	// +kubebuilder:validation:Optional
	GenerateServingCertificate *bool `json:"generateServingCertificate,omitempty" tf:"generate_serving_certificate,omitempty"`

	// Docker image of the kubelet service
	// +kubebuilder:validation:Optional
	Image *string `json:"image,omitempty" tf:"image,omitempty"`

	// The image whose network/ipc namespaces containers in each pod will use
	// +kubebuilder:validation:Optional
	InfraContainerImage *string `json:"infraContainerImage,omitempty" tf:"infra_container_image,omitempty"`
}

type KubeproxyObservation struct {
}

type KubeproxyParameters struct {

	// Extra arguments that are added to the kubeproxy services
	// +kubebuilder:validation:Optional
	ExtraArgs map[string]*string `json:"extraArgs,omitempty" tf:"extra_args,omitempty"`

	// Extra binds added to the worker nodes
	// +kubebuilder:validation:Optional
	ExtraBinds []*string `json:"extraBinds,omitempty" tf:"extra_binds,omitempty"`

	// Extra env added to the worker nodes
	// +kubebuilder:validation:Optional
	ExtraEnv []*string `json:"extraEnv,omitempty" tf:"extra_env,omitempty"`

	// Docker image of the kubeproxy service
	// +kubebuilder:validation:Optional
	Image *string `json:"image,omitempty" tf:"image,omitempty"`
}

type LoadBalancerObservation struct {
}

type LoadBalancerParameters struct {

	// +kubebuilder:validation:Optional
	CreateMonitor *bool `json:"createMonitor,omitempty" tf:"create_monitor,omitempty"`

	// +kubebuilder:validation:Optional
	FloatingNetworkID *string `json:"floatingNetworkId,omitempty" tf:"floating_network_id,omitempty"`

	// +kubebuilder:validation:Optional
	LBMethod *string `json:"lbMethod,omitempty" tf:"lb_method,omitempty"`

	// +kubebuilder:validation:Optional
	LBProvider *string `json:"lbProvider,omitempty" tf:"lb_provider,omitempty"`

	// +kubebuilder:validation:Optional
	LBVersion *string `json:"lbVersion,omitempty" tf:"lb_version,omitempty"`

	// +kubebuilder:validation:Optional
	ManageSecurityGroups *bool `json:"manageSecurityGroups,omitempty" tf:"manage_security_groups,omitempty"`

	// +kubebuilder:validation:Optional
	MonitorDelay *string `json:"monitorDelay,omitempty" tf:"monitor_delay,omitempty"`

	// +kubebuilder:validation:Optional
	MonitorMaxRetries *float64 `json:"monitorMaxRetries,omitempty" tf:"monitor_max_retries,omitempty"`

	// +kubebuilder:validation:Optional
	MonitorTimeout *string `json:"monitorTimeout,omitempty" tf:"monitor_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`

	// +kubebuilder:validation:Optional
	UseOctavia *bool `json:"useOctavia,omitempty" tf:"use_octavia,omitempty"`
}

type MetadataObservation struct {
}

type MetadataParameters struct {

	// +kubebuilder:validation:Optional
	RequestTimeout *float64 `json:"requestTimeout,omitempty" tf:"request_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	SearchOrder *string `json:"searchOrder,omitempty" tf:"search_order,omitempty"`
}

type MonitoringObservation struct {
}

type MonitoringParameters struct {

	// Node selector key pair
	// +kubebuilder:validation:Optional
	NodeSelector map[string]*string `json:"nodeSelector,omitempty" tf:"node_selector,omitempty"`

	// Monitoring options
	// +kubebuilder:validation:Optional
	Options map[string]*string `json:"options,omitempty" tf:"options,omitempty"`

	// Monitoring provider
	// +kubebuilder:validation:Optional
	Provider *string `json:"provider,omitempty" tf:"provider,omitempty"`
}

type NetworkObservation struct {
}

type NetworkParameters struct {

	// +kubebuilder:validation:Optional
	PublicNetwork *string `json:"publicNetwork,omitempty" tf:"public_network,omitempty"`
}

type NodelocalObservation struct {
}

type NodelocalParameters struct {

	// +kubebuilder:validation:Optional
	IPAddress *string `json:"ipAddress,omitempty" tf:"ip_address,omitempty"`

	// Node selector key pair
	// +kubebuilder:validation:Optional
	NodeSelector map[string]*string `json:"nodeSelector,omitempty" tf:"node_selector,omitempty"`
}

type NodesObservation struct {
}

type NodesParameters struct {

	// IP or FQDN that is fully resolvable and used for SSH communication
	// +kubebuilder:validation:Required
	Address *string `json:"address" tf:"address,omitempty"`

	// Docker socket on the node that will be used in tunneling
	// +kubebuilder:validation:Optional
	DockerSocket *string `json:"dockerSocket,omitempty" tf:"docker_socket,omitempty"`

	// Hostname override
	// +kubebuilder:validation:Optional
	HostnameOverride *string `json:"hostnameOverride,omitempty" tf:"hostname_override,omitempty"`

	// Internal address that will be used for components communication
	// +kubebuilder:validation:Optional
	InternalAddress *string `json:"internalAddress,omitempty" tf:"internal_address,omitempty"`

	// Node Labels
	// +kubebuilder:validation:Optional
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// Name of the host provisioned via docker machine
	// +kubebuilder:validation:Optional
	NodeName *string `json:"nodeName,omitempty" tf:"node_name,omitempty"`

	// Port used for SSH communication
	// +kubebuilder:validation:Optional
	Port *string `json:"port,omitempty" tf:"port,omitempty"`

	// Node roles in k8s cluster [controlplane/worker/etcd])
	// +kubebuilder:validation:Required
	Role []*string `json:"role" tf:"role,omitempty"`

	// Node role in kubernetes cluster [controlplane/worker/etcd], specified by a comma-separated string
	// +kubebuilder:validation:Optional
	Roles *string `json:"roles,omitempty" tf:"roles,omitempty"`

	// SSH Agent Auth enable
	// +kubebuilder:validation:Optional
	SSHAgentAuth *bool `json:"sshAgentAuth,omitempty" tf:"ssh_agent_auth,omitempty"`

	// SSH Certificate path
	// +kubebuilder:validation:Optional
	SSHCertPath *string `json:"sshCertPath,omitempty" tf:"ssh_cert_path,omitempty"`

	// SSH Certificate
	// +kubebuilder:validation:Optional
	SSHCertSecretRef *v1.SecretKeySelector `json:"sshCertSecretRef,omitempty" tf:"-"`

	// SSH Private Key path
	// +kubebuilder:validation:Optional
	SSHKeyPath *string `json:"sshKeyPath,omitempty" tf:"ssh_key_path,omitempty"`

	// SSH Private Key
	// +kubebuilder:validation:Optional
	SSHKeySecretRef *v1.SecretKeySelector `json:"sshKeySecretRef,omitempty" tf:"-"`

	// Node taints
	// +kubebuilder:validation:Optional
	Taints []TaintsParameters `json:"taints,omitempty" tf:"taints,omitempty"`

	// SSH user that will be used by RKE
	// +kubebuilder:validation:Required
	UserSecretRef v1.SecretKeySelector `json:"userSecretRef" tf:"-"`
}

type OpenstackCloudConfigGlobalObservation struct {
}

type OpenstackCloudConfigGlobalParameters struct {

	// +kubebuilder:validation:Required
	AuthURL *string `json:"authUrl" tf:"auth_url,omitempty"`

	// +kubebuilder:validation:Optional
	CAFile *string `json:"caFile,omitempty" tf:"ca_file,omitempty"`

	// +kubebuilder:validation:Optional
	DomainIDSecretRef *v1.SecretKeySelector `json:"domainIdSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	DomainName *string `json:"domainName,omitempty" tf:"domain_name,omitempty"`

	// +kubebuilder:validation:Required
	PasswordSecretRef v1.SecretKeySelector `json:"passwordSecretRef" tf:"-"`

	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// +kubebuilder:validation:Optional
	TenantIDSecretRef *v1.SecretKeySelector `json:"tenantIdSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	TenantName *string `json:"tenantName,omitempty" tf:"tenant_name,omitempty"`

	// +kubebuilder:validation:Optional
	TrustIDSecretRef *v1.SecretKeySelector `json:"trustIdSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	UserIDSecretRef *v1.SecretKeySelector `json:"userIdSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	Username *string `json:"username,omitempty" tf:"username,omitempty"`
}

type OpenstackCloudConfigObservation struct {
}

type OpenstackCloudConfigParameters struct {

	// +kubebuilder:validation:Optional
	BlockStorage []BlockStorageParameters `json:"blockStorage,omitempty" tf:"block_storage,omitempty"`

	// +kubebuilder:validation:Required
	Global []OpenstackCloudConfigGlobalParameters `json:"global" tf:"global,omitempty"`

	// +kubebuilder:validation:Optional
	LoadBalancer []LoadBalancerParameters `json:"loadBalancer,omitempty" tf:"load_balancer,omitempty"`

	// +kubebuilder:validation:Optional
	Metadata []MetadataParameters `json:"metadata,omitempty" tf:"metadata,omitempty"`

	// +kubebuilder:validation:Optional
	Route []RouteParameters `json:"route,omitempty" tf:"route,omitempty"`
}

type OpenstackCloudProviderBlockStorageObservation struct {
}

type OpenstackCloudProviderBlockStorageParameters struct {

	// +kubebuilder:validation:Optional
	BsVersion *string `json:"bsVersion,omitempty" tf:"bs_version,omitempty"`

	// +kubebuilder:validation:Optional
	IgnoreVolumeAz *bool `json:"ignoreVolumeAz,omitempty" tf:"ignore_volume_az,omitempty"`

	// +kubebuilder:validation:Optional
	TrustDevicePath *bool `json:"trustDevicePath,omitempty" tf:"trust_device_path,omitempty"`
}

type OpenstackCloudProviderGlobalObservation struct {
}

type OpenstackCloudProviderGlobalParameters struct {

	// +kubebuilder:validation:Required
	AuthURL *string `json:"authUrl" tf:"auth_url,omitempty"`

	// +kubebuilder:validation:Optional
	CAFile *string `json:"caFile,omitempty" tf:"ca_file,omitempty"`

	// +kubebuilder:validation:Optional
	DomainIDSecretRef *v1.SecretKeySelector `json:"domainIdSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	DomainName *string `json:"domainName,omitempty" tf:"domain_name,omitempty"`

	// +kubebuilder:validation:Required
	PasswordSecretRef v1.SecretKeySelector `json:"passwordSecretRef" tf:"-"`

	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// +kubebuilder:validation:Optional
	TenantIDSecretRef *v1.SecretKeySelector `json:"tenantIdSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	TenantName *string `json:"tenantName,omitempty" tf:"tenant_name,omitempty"`

	// +kubebuilder:validation:Optional
	TrustIDSecretRef *v1.SecretKeySelector `json:"trustIdSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	UserIDSecretRef *v1.SecretKeySelector `json:"userIdSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	Username *string `json:"username,omitempty" tf:"username,omitempty"`
}

type OpenstackCloudProviderLoadBalancerObservation struct {
}

type OpenstackCloudProviderLoadBalancerParameters struct {

	// +kubebuilder:validation:Optional
	CreateMonitor *bool `json:"createMonitor,omitempty" tf:"create_monitor,omitempty"`

	// +kubebuilder:validation:Optional
	FloatingNetworkID *string `json:"floatingNetworkId,omitempty" tf:"floating_network_id,omitempty"`

	// +kubebuilder:validation:Optional
	LBMethod *string `json:"lbMethod,omitempty" tf:"lb_method,omitempty"`

	// +kubebuilder:validation:Optional
	LBProvider *string `json:"lbProvider,omitempty" tf:"lb_provider,omitempty"`

	// +kubebuilder:validation:Optional
	LBVersion *string `json:"lbVersion,omitempty" tf:"lb_version,omitempty"`

	// +kubebuilder:validation:Optional
	ManageSecurityGroups *bool `json:"manageSecurityGroups,omitempty" tf:"manage_security_groups,omitempty"`

	// +kubebuilder:validation:Optional
	MonitorDelay *string `json:"monitorDelay,omitempty" tf:"monitor_delay,omitempty"`

	// +kubebuilder:validation:Optional
	MonitorMaxRetries *float64 `json:"monitorMaxRetries,omitempty" tf:"monitor_max_retries,omitempty"`

	// +kubebuilder:validation:Optional
	MonitorTimeout *string `json:"monitorTimeout,omitempty" tf:"monitor_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`

	// +kubebuilder:validation:Optional
	UseOctavia *bool `json:"useOctavia,omitempty" tf:"use_octavia,omitempty"`
}

type OpenstackCloudProviderMetadataObservation struct {
}

type OpenstackCloudProviderMetadataParameters struct {

	// +kubebuilder:validation:Optional
	RequestTimeout *float64 `json:"requestTimeout,omitempty" tf:"request_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	SearchOrder *string `json:"searchOrder,omitempty" tf:"search_order,omitempty"`
}

type OpenstackCloudProviderObservation struct {
}

type OpenstackCloudProviderParameters struct {

	// +kubebuilder:validation:Optional
	BlockStorage []OpenstackCloudProviderBlockStorageParameters `json:"blockStorage,omitempty" tf:"block_storage,omitempty"`

	// +kubebuilder:validation:Required
	Global []OpenstackCloudProviderGlobalParameters `json:"global" tf:"global,omitempty"`

	// +kubebuilder:validation:Optional
	LoadBalancer []OpenstackCloudProviderLoadBalancerParameters `json:"loadBalancer,omitempty" tf:"load_balancer,omitempty"`

	// +kubebuilder:validation:Optional
	Metadata []OpenstackCloudProviderMetadataParameters `json:"metadata,omitempty" tf:"metadata,omitempty"`

	// +kubebuilder:validation:Optional
	Route []OpenstackCloudProviderRouteParameters `json:"route,omitempty" tf:"route,omitempty"`
}

type OpenstackCloudProviderRouteObservation struct {
}

type OpenstackCloudProviderRouteParameters struct {

	// +kubebuilder:validation:Optional
	RouterID *string `json:"routerId,omitempty" tf:"router_id,omitempty"`
}

type PrivateRegistriesObservation struct {
}

type PrivateRegistriesParameters struct {

	// Set as default registry
	// +kubebuilder:validation:Optional
	IsDefault *bool `json:"isDefault,omitempty" tf:"is_default,omitempty"`

	// Registry password
	// +kubebuilder:validation:Optional
	PasswordSecretRef *v1.SecretKeySelector `json:"passwordSecretRef,omitempty" tf:"-"`

	// Registry URL
	// +kubebuilder:validation:Required
	URL *string `json:"url" tf:"url,omitempty"`

	// Registry user
	// +kubebuilder:validation:Optional
	UserSecretRef *v1.SecretKeySelector `json:"userSecretRef,omitempty" tf:"-"`
}

type RestoreObservation struct {
}

type RestoreParameters struct {

	// Restore RKE cluster
	// +kubebuilder:validation:Optional
	Restore *bool `json:"restore,omitempty" tf:"restore,omitempty"`

	// Snapshot name
	// +kubebuilder:validation:Optional
	SnapshotName *string `json:"snapshotName,omitempty" tf:"snapshot_name,omitempty"`
}

type RotateCertificatesObservation struct {
}

type RotateCertificatesParameters struct {

	// Rotate CA Certificates
	// +kubebuilder:validation:Optional
	CACertificates *bool `json:"caCertificates,omitempty" tf:"ca_certificates,omitempty"`

	// Services to rotate their certs. valid values are etcd|kubelet|kube-apiserver|kube-proxy|kube-scheduler|kube-controller-manager
	// +kubebuilder:validation:Optional
	Services []*string `json:"services,omitempty" tf:"services,omitempty"`
}

type RouteObservation struct {
}

type RouteParameters struct {

	// +kubebuilder:validation:Optional
	RouterID *string `json:"routerId,omitempty" tf:"router_id,omitempty"`
}

type RunningSystemImagesObservation struct {
	AciCniDeployContainer *string `json:"aciCniDeployContainer,omitempty" tf:"aci_cni_deploy_container,omitempty"`

	AciControllerContainer *string `json:"aciControllerContainer,omitempty" tf:"aci_controller_container,omitempty"`

	AciHostContainer *string `json:"aciHostContainer,omitempty" tf:"aci_host_container,omitempty"`

	AciMcastContainer *string `json:"aciMcastContainer,omitempty" tf:"aci_mcast_container,omitempty"`

	AciOpflexContainer *string `json:"aciOpflexContainer,omitempty" tf:"aci_opflex_container,omitempty"`

	AciOvsContainer *string `json:"aciOvsContainer,omitempty" tf:"aci_ovs_container,omitempty"`

	Alpine *string `json:"alpine,omitempty" tf:"alpine,omitempty"`

	CalicoCni *string `json:"calicoCni,omitempty" tf:"calico_cni,omitempty"`

	CalicoControllers *string `json:"calicoControllers,omitempty" tf:"calico_controllers,omitempty"`

	CalicoCtl *string `json:"calicoCtl,omitempty" tf:"calico_ctl,omitempty"`

	CalicoFlexVol *string `json:"calicoFlexVol,omitempty" tf:"calico_flex_vol,omitempty"`

	CalicoNode *string `json:"calicoNode,omitempty" tf:"calico_node,omitempty"`

	CanalCni *string `json:"canalCni,omitempty" tf:"canal_cni,omitempty"`

	CanalFlannel *string `json:"canalFlannel,omitempty" tf:"canal_flannel,omitempty"`

	CanalFlexVol *string `json:"canalFlexVol,omitempty" tf:"canal_flex_vol,omitempty"`

	CanalNode *string `json:"canalNode,omitempty" tf:"canal_node,omitempty"`

	CertDownloader *string `json:"certDownloader,omitempty" tf:"cert_downloader,omitempty"`

	Coredns *string `json:"coredns,omitempty" tf:"coredns,omitempty"`

	CorednsAutoscaler *string `json:"corednsAutoscaler,omitempty" tf:"coredns_autoscaler,omitempty"`

	Dnsmasq *string `json:"dnsmasq,omitempty" tf:"dnsmasq,omitempty"`

	Etcd *string `json:"etcd,omitempty" tf:"etcd,omitempty"`

	Flannel *string `json:"flannel,omitempty" tf:"flannel,omitempty"`

	FlannelCni *string `json:"flannelCni,omitempty" tf:"flannel_cni,omitempty"`

	Ingress *string `json:"ingress,omitempty" tf:"ingress,omitempty"`

	IngressBackend *string `json:"ingressBackend,omitempty" tf:"ingress_backend,omitempty"`

	KubeDNS *string `json:"kubeDns,omitempty" tf:"kube_dns,omitempty"`

	KubeDNSAutoscaler *string `json:"kubeDnsAutoscaler,omitempty" tf:"kube_dns_autoscaler,omitempty"`

	KubeDNSSidecar *string `json:"kubeDnsSidecar,omitempty" tf:"kube_dns_sidecar,omitempty"`

	Kubernetes *string `json:"kubernetes,omitempty" tf:"kubernetes,omitempty"`

	KubernetesServicesSidecar *string `json:"kubernetesServicesSidecar,omitempty" tf:"kubernetes_services_sidecar,omitempty"`

	MetricsServer *string `json:"metricsServer,omitempty" tf:"metrics_server,omitempty"`

	NginxProxy *string `json:"nginxProxy,omitempty" tf:"nginx_proxy,omitempty"`

	Nodelocal *string `json:"nodelocal,omitempty" tf:"nodelocal,omitempty"`

	PodInfraContainer *string `json:"podInfraContainer,omitempty" tf:"pod_infra_container,omitempty"`

	WeaveCni *string `json:"weaveCni,omitempty" tf:"weave_cni,omitempty"`

	WeaveNode *string `json:"weaveNode,omitempty" tf:"weave_node,omitempty"`

	WindowsPodInfraContainer *string `json:"windowsPodInfraContainer,omitempty" tf:"windows_pod_infra_container,omitempty"`
}

type RunningSystemImagesParameters struct {
}

type S3BackupConfigObservation struct {
}

type S3BackupConfigParameters struct {

	// +kubebuilder:validation:Optional
	AccessKeySecretRef *v1.SecretKeySelector `json:"accessKeySecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	BucketName *string `json:"bucketName,omitempty" tf:"bucket_name,omitempty"`

	// +kubebuilder:validation:Optional
	CustomCA *string `json:"customCa,omitempty" tf:"custom_ca,omitempty"`

	// +kubebuilder:validation:Optional
	Endpoint *string `json:"endpoint,omitempty" tf:"endpoint,omitempty"`

	// +kubebuilder:validation:Optional
	Folder *string `json:"folder,omitempty" tf:"folder,omitempty"`

	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// +kubebuilder:validation:Optional
	SecretKeySecretRef *v1.SecretKeySelector `json:"secretKeySecretRef,omitempty" tf:"-"`
}

type SchedulerObservation struct {
}

type SchedulerParameters struct {

	// Extra arguments that are added to the scheduler services
	// +kubebuilder:validation:Optional
	ExtraArgs map[string]*string `json:"extraArgs,omitempty" tf:"extra_args,omitempty"`

	// Extra binds added to the controlplane nodes
	// +kubebuilder:validation:Optional
	ExtraBinds []*string `json:"extraBinds,omitempty" tf:"extra_binds,omitempty"`

	// Extra env added to the controlplane nodes
	// +kubebuilder:validation:Optional
	ExtraEnv []*string `json:"extraEnv,omitempty" tf:"extra_env,omitempty"`

	// Docker image of the scheduler service
	// +kubebuilder:validation:Optional
	Image *string `json:"image,omitempty" tf:"image,omitempty"`
}

type SecretsEncryptionConfigObservation struct {
}

type SecretsEncryptionConfigParameters struct {

	// +kubebuilder:validation:Optional
	CustomConfig *string `json:"customConfig,omitempty" tf:"custom_config,omitempty"`

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type ServiceOverrideObservation struct {
}

type ServiceOverrideParameters struct {

	// +kubebuilder:validation:Optional
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// +kubebuilder:validation:Required
	Service *string `json:"service" tf:"service,omitempty"`

	// +kubebuilder:validation:Optional
	SigningMethod *string `json:"signingMethod,omitempty" tf:"signing_method,omitempty"`

	// +kubebuilder:validation:Optional
	SigningName *string `json:"signingName,omitempty" tf:"signing_name,omitempty"`

	// +kubebuilder:validation:Optional
	SigningRegion *string `json:"signingRegion,omitempty" tf:"signing_region,omitempty"`

	// +kubebuilder:validation:Optional
	URL *string `json:"url,omitempty" tf:"url,omitempty"`
}

type ServicesEtcdBackupConfigObservation struct {
}

type ServicesEtcdBackupConfigParameters struct {

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// +kubebuilder:validation:Optional
	IntervalHours *float64 `json:"intervalHours,omitempty" tf:"interval_hours,omitempty"`

	// +kubebuilder:validation:Optional
	Retention *float64 `json:"retention,omitempty" tf:"retention,omitempty"`

	// +kubebuilder:validation:Optional
	S3BackupConfig []BackupConfigS3BackupConfigParameters `json:"s3BackupConfig,omitempty" tf:"s3_backup_config,omitempty"`

	// +kubebuilder:validation:Optional
	SafeTimestamp *bool `json:"safeTimestamp,omitempty" tf:"safe_timestamp,omitempty"`

	// +kubebuilder:validation:Optional
	Timeout *float64 `json:"timeout,omitempty" tf:"timeout,omitempty"`
}

type ServicesEtcdObservation struct {
}

type ServicesEtcdParameters struct {

	// +kubebuilder:validation:Optional
	BackupConfig []ServicesEtcdBackupConfigParameters `json:"backupConfig,omitempty" tf:"backup_config,omitempty"`

	// +kubebuilder:validation:Optional
	CACertSecretRef *v1.SecretKeySelector `json:"caCertSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	CertSecretRef *v1.SecretKeySelector `json:"certSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	Creation *string `json:"creation,omitempty" tf:"creation,omitempty"`

	// +kubebuilder:validation:Optional
	ExternalUrls []*string `json:"externalUrls,omitempty" tf:"external_urls,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraArgs map[string]*string `json:"extraArgs,omitempty" tf:"extra_args,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraBinds []*string `json:"extraBinds,omitempty" tf:"extra_binds,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraEnv []*string `json:"extraEnv,omitempty" tf:"extra_env,omitempty"`

	// +kubebuilder:validation:Optional
	GID *float64 `json:"gid,omitempty" tf:"gid,omitempty"`

	// +kubebuilder:validation:Optional
	Image *string `json:"image,omitempty" tf:"image,omitempty"`

	// +kubebuilder:validation:Optional
	KeySecretRef *v1.SecretKeySelector `json:"keySecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// +kubebuilder:validation:Optional
	Retention *string `json:"retention,omitempty" tf:"retention,omitempty"`

	// +kubebuilder:validation:Optional
	Snapshot *bool `json:"snapshot,omitempty" tf:"snapshot,omitempty"`

	// +kubebuilder:validation:Optional
	UID *float64 `json:"uid,omitempty" tf:"uid,omitempty"`
}

type ServicesKubeAPIAuditLogObservation struct {
}

type ServicesKubeAPIAuditLogParameters struct {

	// +kubebuilder:validation:Optional
	Configuration []AuditLogConfigurationParameters `json:"configuration,omitempty" tf:"configuration,omitempty"`

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type ServicesKubeAPIEventRateLimitObservation struct {
}

type ServicesKubeAPIEventRateLimitParameters struct {

	// +kubebuilder:validation:Optional
	Configuration *string `json:"configuration,omitempty" tf:"configuration,omitempty"`

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type ServicesKubeAPIObservation struct {
}

type ServicesKubeAPIParameters struct {

	// Enable/Disable AlwaysPullImages admissions plugin
	// +kubebuilder:validation:Optional
	AlwaysPullImages *bool `json:"alwaysPullImages,omitempty" tf:"always_pull_images,omitempty"`

	// +kubebuilder:validation:Optional
	AuditLog []ServicesKubeAPIAuditLogParameters `json:"auditLog,omitempty" tf:"audit_log,omitempty"`

	// +kubebuilder:validation:Optional
	EventRateLimit []ServicesKubeAPIEventRateLimitParameters `json:"eventRateLimit,omitempty" tf:"event_rate_limit,omitempty"`

	// Extra arguments that are added to the kube-api services
	// +kubebuilder:validation:Optional
	ExtraArgs map[string]*string `json:"extraArgs,omitempty" tf:"extra_args,omitempty"`

	// Extra binds added to the controlplane nodes
	// +kubebuilder:validation:Optional
	ExtraBinds []*string `json:"extraBinds,omitempty" tf:"extra_binds,omitempty"`

	// Extra env added to the controlplane nodes
	// +kubebuilder:validation:Optional
	ExtraEnv []*string `json:"extraEnv,omitempty" tf:"extra_env,omitempty"`

	// +kubebuilder:validation:Optional
	Image *string `json:"image,omitempty" tf:"image,omitempty"`

	// Enabled/Disable PodSecurityPolicy
	// +kubebuilder:validation:Optional
	PodSecurityPolicy *bool `json:"podSecurityPolicy,omitempty" tf:"pod_security_policy,omitempty"`

	// +kubebuilder:validation:Optional
	SecretsEncryptionConfig []ServicesKubeAPISecretsEncryptionConfigParameters `json:"secretsEncryptionConfig,omitempty" tf:"secrets_encryption_config,omitempty"`

	// Virtual IP range that will be used by Kubernetes services
	// +kubebuilder:validation:Optional
	ServiceClusterIPRange *string `json:"serviceClusterIpRange,omitempty" tf:"service_cluster_ip_range,omitempty"`

	// Port range for services defined with NodePort type
	// +kubebuilder:validation:Optional
	ServiceNodePortRange *string `json:"serviceNodePortRange,omitempty" tf:"service_node_port_range,omitempty"`
}

type ServicesKubeAPISecretsEncryptionConfigObservation struct {
}

type ServicesKubeAPISecretsEncryptionConfigParameters struct {

	// +kubebuilder:validation:Optional
	CustomConfig *string `json:"customConfig,omitempty" tf:"custom_config,omitempty"`

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type ServicesKubeControllerObservation struct {
}

type ServicesKubeControllerParameters struct {

	// CIDR Range for Pods in cluster
	// +kubebuilder:validation:Optional
	ClusterCidr *string `json:"clusterCidr,omitempty" tf:"cluster_cidr,omitempty"`

	// Extra arguments that are added to the kube-controller service
	// +kubebuilder:validation:Optional
	ExtraArgs map[string]*string `json:"extraArgs,omitempty" tf:"extra_args,omitempty"`

	// Extra binds added to the controlplane nodes
	// +kubebuilder:validation:Optional
	ExtraBinds []*string `json:"extraBinds,omitempty" tf:"extra_binds,omitempty"`

	// Extra env added to the controlplane nodes
	// +kubebuilder:validation:Optional
	ExtraEnv []*string `json:"extraEnv,omitempty" tf:"extra_env,omitempty"`

	// Docker image of the kube-controller service
	// +kubebuilder:validation:Optional
	Image *string `json:"image,omitempty" tf:"image,omitempty"`

	// Virtual IP range that will be used by Kubernetes services
	// +kubebuilder:validation:Optional
	ServiceClusterIPRange *string `json:"serviceClusterIpRange,omitempty" tf:"service_cluster_ip_range,omitempty"`
}

type ServicesKubeletObservation struct {
}

type ServicesKubeletParameters struct {

	// Cluster DNS service ip
	// +kubebuilder:validation:Optional
	ClusterDNSServer *string `json:"clusterDnsServer,omitempty" tf:"cluster_dns_server,omitempty"`

	// Domain of the cluster
	// +kubebuilder:validation:Optional
	ClusterDomain *string `json:"clusterDomain,omitempty" tf:"cluster_domain,omitempty"`

	// Extra arguments that are added to the kubelet services
	// +kubebuilder:validation:Optional
	ExtraArgs map[string]*string `json:"extraArgs,omitempty" tf:"extra_args,omitempty"`

	// Extra binds added to the worker nodes
	// +kubebuilder:validation:Optional
	ExtraBinds []*string `json:"extraBinds,omitempty" tf:"extra_binds,omitempty"`

	// Extra env added to the nodes
	// +kubebuilder:validation:Optional
	ExtraEnv []*string `json:"extraEnv,omitempty" tf:"extra_env,omitempty"`

	// Fail if swap is enabled
	// +kubebuilder:validation:Optional
	FailSwapOn *bool `json:"failSwapOn,omitempty" tf:"fail_swap_on,omitempty"`

	// +kubebuilder:validation:Optional
	GenerateServingCertificate *bool `json:"generateServingCertificate,omitempty" tf:"generate_serving_certificate,omitempty"`

	// Docker image of the kubelet service
	// +kubebuilder:validation:Optional
	Image *string `json:"image,omitempty" tf:"image,omitempty"`

	// The image whose network/ipc namespaces containers in each pod will use
	// +kubebuilder:validation:Optional
	InfraContainerImage *string `json:"infraContainerImage,omitempty" tf:"infra_container_image,omitempty"`
}

type ServicesKubeproxyObservation struct {
}

type ServicesKubeproxyParameters struct {

	// Extra arguments that are added to the kubeproxy services
	// +kubebuilder:validation:Optional
	ExtraArgs map[string]*string `json:"extraArgs,omitempty" tf:"extra_args,omitempty"`

	// Extra binds added to the worker nodes
	// +kubebuilder:validation:Optional
	ExtraBinds []*string `json:"extraBinds,omitempty" tf:"extra_binds,omitempty"`

	// Extra env added to the worker nodes
	// +kubebuilder:validation:Optional
	ExtraEnv []*string `json:"extraEnv,omitempty" tf:"extra_env,omitempty"`

	// Docker image of the kubeproxy service
	// +kubebuilder:validation:Optional
	Image *string `json:"image,omitempty" tf:"image,omitempty"`
}

type ServicesObservation struct {
}

type ServicesParameters struct {

	// +kubebuilder:validation:Optional
	Etcd []EtcdParameters `json:"etcd,omitempty" tf:"etcd,omitempty"`

	// +kubebuilder:validation:Optional
	KubeAPI []KubeAPIParameters `json:"kubeApi,omitempty" tf:"kube_api,omitempty"`

	// +kubebuilder:validation:Optional
	KubeController []KubeControllerParameters `json:"kubeController,omitempty" tf:"kube_controller,omitempty"`

	// +kubebuilder:validation:Optional
	Kubelet []KubeletParameters `json:"kubelet,omitempty" tf:"kubelet,omitempty"`

	// +kubebuilder:validation:Optional
	Kubeproxy []KubeproxyParameters `json:"kubeproxy,omitempty" tf:"kubeproxy,omitempty"`

	// +kubebuilder:validation:Optional
	Scheduler []SchedulerParameters `json:"scheduler,omitempty" tf:"scheduler,omitempty"`
}

type ServicesSchedulerObservation struct {
}

type ServicesSchedulerParameters struct {

	// Extra arguments that are added to the scheduler services
	// +kubebuilder:validation:Optional
	ExtraArgs map[string]*string `json:"extraArgs,omitempty" tf:"extra_args,omitempty"`

	// Extra binds added to the controlplane nodes
	// +kubebuilder:validation:Optional
	ExtraBinds []*string `json:"extraBinds,omitempty" tf:"extra_binds,omitempty"`

	// Extra env added to the controlplane nodes
	// +kubebuilder:validation:Optional
	ExtraEnv []*string `json:"extraEnv,omitempty" tf:"extra_env,omitempty"`

	// Docker image of the scheduler service
	// +kubebuilder:validation:Optional
	Image *string `json:"image,omitempty" tf:"image,omitempty"`
}

type SystemImagesObservation struct {
}

type SystemImagesParameters struct {

	// +kubebuilder:validation:Optional
	AciCniDeployContainer *string `json:"aciCniDeployContainer,omitempty" tf:"aci_cni_deploy_container,omitempty"`

	// +kubebuilder:validation:Optional
	AciControllerContainer *string `json:"aciControllerContainer,omitempty" tf:"aci_controller_container,omitempty"`

	// +kubebuilder:validation:Optional
	AciHostContainer *string `json:"aciHostContainer,omitempty" tf:"aci_host_container,omitempty"`

	// +kubebuilder:validation:Optional
	AciMcastContainer *string `json:"aciMcastContainer,omitempty" tf:"aci_mcast_container,omitempty"`

	// +kubebuilder:validation:Optional
	AciOpflexContainer *string `json:"aciOpflexContainer,omitempty" tf:"aci_opflex_container,omitempty"`

	// +kubebuilder:validation:Optional
	AciOvsContainer *string `json:"aciOvsContainer,omitempty" tf:"aci_ovs_container,omitempty"`

	// +kubebuilder:validation:Optional
	Alpine *string `json:"alpine,omitempty" tf:"alpine,omitempty"`

	// +kubebuilder:validation:Optional
	CalicoCni *string `json:"calicoCni,omitempty" tf:"calico_cni,omitempty"`

	// +kubebuilder:validation:Optional
	CalicoControllers *string `json:"calicoControllers,omitempty" tf:"calico_controllers,omitempty"`

	// +kubebuilder:validation:Optional
	CalicoCtl *string `json:"calicoCtl,omitempty" tf:"calico_ctl,omitempty"`

	// +kubebuilder:validation:Optional
	CalicoFlexVol *string `json:"calicoFlexVol,omitempty" tf:"calico_flex_vol,omitempty"`

	// +kubebuilder:validation:Optional
	CalicoNode *string `json:"calicoNode,omitempty" tf:"calico_node,omitempty"`

	// +kubebuilder:validation:Optional
	CanalCni *string `json:"canalCni,omitempty" tf:"canal_cni,omitempty"`

	// +kubebuilder:validation:Optional
	CanalFlannel *string `json:"canalFlannel,omitempty" tf:"canal_flannel,omitempty"`

	// +kubebuilder:validation:Optional
	CanalFlexVol *string `json:"canalFlexVol,omitempty" tf:"canal_flex_vol,omitempty"`

	// +kubebuilder:validation:Optional
	CanalNode *string `json:"canalNode,omitempty" tf:"canal_node,omitempty"`

	// +kubebuilder:validation:Optional
	CertDownloader *string `json:"certDownloader,omitempty" tf:"cert_downloader,omitempty"`

	// +kubebuilder:validation:Optional
	Coredns *string `json:"coredns,omitempty" tf:"coredns,omitempty"`

	// +kubebuilder:validation:Optional
	CorednsAutoscaler *string `json:"corednsAutoscaler,omitempty" tf:"coredns_autoscaler,omitempty"`

	// +kubebuilder:validation:Optional
	Dnsmasq *string `json:"dnsmasq,omitempty" tf:"dnsmasq,omitempty"`

	// +kubebuilder:validation:Optional
	Etcd *string `json:"etcd,omitempty" tf:"etcd,omitempty"`

	// +kubebuilder:validation:Optional
	Flannel *string `json:"flannel,omitempty" tf:"flannel,omitempty"`

	// +kubebuilder:validation:Optional
	FlannelCni *string `json:"flannelCni,omitempty" tf:"flannel_cni,omitempty"`

	// +kubebuilder:validation:Optional
	Ingress *string `json:"ingress,omitempty" tf:"ingress,omitempty"`

	// +kubebuilder:validation:Optional
	IngressBackend *string `json:"ingressBackend,omitempty" tf:"ingress_backend,omitempty"`

	// +kubebuilder:validation:Optional
	KubeDNS *string `json:"kubeDns,omitempty" tf:"kube_dns,omitempty"`

	// +kubebuilder:validation:Optional
	KubeDNSAutoscaler *string `json:"kubeDnsAutoscaler,omitempty" tf:"kube_dns_autoscaler,omitempty"`

	// +kubebuilder:validation:Optional
	KubeDNSSidecar *string `json:"kubeDnsSidecar,omitempty" tf:"kube_dns_sidecar,omitempty"`

	// +kubebuilder:validation:Optional
	Kubernetes *string `json:"kubernetes,omitempty" tf:"kubernetes,omitempty"`

	// +kubebuilder:validation:Optional
	KubernetesServicesSidecar *string `json:"kubernetesServicesSidecar,omitempty" tf:"kubernetes_services_sidecar,omitempty"`

	// +kubebuilder:validation:Optional
	MetricsServer *string `json:"metricsServer,omitempty" tf:"metrics_server,omitempty"`

	// +kubebuilder:validation:Optional
	NginxProxy *string `json:"nginxProxy,omitempty" tf:"nginx_proxy,omitempty"`

	// +kubebuilder:validation:Optional
	Nodelocal *string `json:"nodelocal,omitempty" tf:"nodelocal,omitempty"`

	// +kubebuilder:validation:Optional
	PodInfraContainer *string `json:"podInfraContainer,omitempty" tf:"pod_infra_container,omitempty"`

	// +kubebuilder:validation:Optional
	WeaveCni *string `json:"weaveCni,omitempty" tf:"weave_cni,omitempty"`

	// +kubebuilder:validation:Optional
	WeaveNode *string `json:"weaveNode,omitempty" tf:"weave_node,omitempty"`

	// +kubebuilder:validation:Optional
	WindowsPodInfraContainer *string `json:"windowsPodInfraContainer,omitempty" tf:"windows_pod_infra_container,omitempty"`
}

type TaintsObservation struct {
}

type TaintsParameters struct {

	// +kubebuilder:validation:Optional
	Effect *string `json:"effect,omitempty" tf:"effect,omitempty"`

	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type UpgradeStrategyObservation struct {
}

type UpgradeStrategyParameters struct {

	// +kubebuilder:validation:Optional
	Drain *bool `json:"drain,omitempty" tf:"drain,omitempty"`

	// +kubebuilder:validation:Optional
	DrainInput []DrainInputParameters `json:"drainInput,omitempty" tf:"drain_input,omitempty"`

	// +kubebuilder:validation:Optional
	MaxUnavailableControlplane *string `json:"maxUnavailableControlplane,omitempty" tf:"max_unavailable_controlplane,omitempty"`

	// +kubebuilder:validation:Optional
	MaxUnavailableWorker *string `json:"maxUnavailableWorker,omitempty" tf:"max_unavailable_worker,omitempty"`
}

type VirtualCenterObservation struct {
}

type VirtualCenterParameters struct {

	// +kubebuilder:validation:Required
	Datacenters *string `json:"datacenters" tf:"datacenters,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	PasswordSecretRef v1.SecretKeySelector `json:"passwordSecretRef" tf:"-"`

	// +kubebuilder:validation:Optional
	Port *string `json:"port,omitempty" tf:"port,omitempty"`

	// +kubebuilder:validation:Optional
	SoapRoundtripCount *float64 `json:"soapRoundtripCount,omitempty" tf:"soap_roundtrip_count,omitempty"`

	// +kubebuilder:validation:Required
	UserSecretRef v1.SecretKeySelector `json:"userSecretRef" tf:"-"`
}

type VsphereCloudConfigGlobalObservation struct {
}

type VsphereCloudConfigGlobalParameters struct {

	// +kubebuilder:validation:Optional
	Datacenter *string `json:"datacenter,omitempty" tf:"datacenter,omitempty"`

	// +kubebuilder:validation:Optional
	Datacenters *string `json:"datacenters,omitempty" tf:"datacenters,omitempty"`

	// +kubebuilder:validation:Optional
	Datastore *string `json:"datastore,omitempty" tf:"datastore,omitempty"`

	// +kubebuilder:validation:Optional
	InsecureFlag *bool `json:"insecureFlag,omitempty" tf:"insecure_flag,omitempty"`

	// +kubebuilder:validation:Optional
	PasswordSecretRef *v1.SecretKeySelector `json:"passwordSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	Port *string `json:"port,omitempty" tf:"port,omitempty"`

	// +kubebuilder:validation:Optional
	SoapRoundtripCount *float64 `json:"soapRoundtripCount,omitempty" tf:"soap_roundtrip_count,omitempty"`

	// +kubebuilder:validation:Optional
	UserSecretRef *v1.SecretKeySelector `json:"userSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	VMName *string `json:"vmName,omitempty" tf:"vm_name,omitempty"`

	// +kubebuilder:validation:Optional
	VMUUID *string `json:"vmUuid,omitempty" tf:"vm_uuid,omitempty"`

	// +kubebuilder:validation:Optional
	WorkingDir *string `json:"workingDir,omitempty" tf:"working_dir,omitempty"`
}

type VsphereCloudConfigObservation struct {
}

type VsphereCloudConfigParameters struct {

	// +kubebuilder:validation:Optional
	Disk []DiskParameters `json:"disk,omitempty" tf:"disk,omitempty"`

	// +kubebuilder:validation:Optional
	Global []VsphereCloudConfigGlobalParameters `json:"global,omitempty" tf:"global,omitempty"`

	// +kubebuilder:validation:Optional
	Network []NetworkParameters `json:"network,omitempty" tf:"network,omitempty"`

	// +kubebuilder:validation:Required
	VirtualCenter []VirtualCenterParameters `json:"virtualCenter" tf:"virtual_center,omitempty"`

	// +kubebuilder:validation:Required
	Workspace []WorkspaceParameters `json:"workspace" tf:"workspace,omitempty"`
}

type VsphereCloudProviderDiskObservation struct {
}

type VsphereCloudProviderDiskParameters struct {

	// +kubebuilder:validation:Optional
	ScsiControllerType *string `json:"scsiControllerType,omitempty" tf:"scsi_controller_type,omitempty"`
}

type VsphereCloudProviderGlobalObservation struct {
}

type VsphereCloudProviderGlobalParameters struct {

	// +kubebuilder:validation:Optional
	Datacenter *string `json:"datacenter,omitempty" tf:"datacenter,omitempty"`

	// +kubebuilder:validation:Optional
	Datacenters *string `json:"datacenters,omitempty" tf:"datacenters,omitempty"`

	// +kubebuilder:validation:Optional
	Datastore *string `json:"datastore,omitempty" tf:"datastore,omitempty"`

	// +kubebuilder:validation:Optional
	InsecureFlag *bool `json:"insecureFlag,omitempty" tf:"insecure_flag,omitempty"`

	// +kubebuilder:validation:Optional
	PasswordSecretRef *v1.SecretKeySelector `json:"passwordSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	Port *string `json:"port,omitempty" tf:"port,omitempty"`

	// +kubebuilder:validation:Optional
	SoapRoundtripCount *float64 `json:"soapRoundtripCount,omitempty" tf:"soap_roundtrip_count,omitempty"`

	// +kubebuilder:validation:Optional
	UserSecretRef *v1.SecretKeySelector `json:"userSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	VMName *string `json:"vmName,omitempty" tf:"vm_name,omitempty"`

	// +kubebuilder:validation:Optional
	VMUUID *string `json:"vmUuid,omitempty" tf:"vm_uuid,omitempty"`

	// +kubebuilder:validation:Optional
	WorkingDir *string `json:"workingDir,omitempty" tf:"working_dir,omitempty"`
}

type VsphereCloudProviderNetworkObservation struct {
}

type VsphereCloudProviderNetworkParameters struct {

	// +kubebuilder:validation:Optional
	PublicNetwork *string `json:"publicNetwork,omitempty" tf:"public_network,omitempty"`
}

type VsphereCloudProviderObservation struct {
}

type VsphereCloudProviderParameters struct {

	// +kubebuilder:validation:Optional
	Disk []VsphereCloudProviderDiskParameters `json:"disk,omitempty" tf:"disk,omitempty"`

	// +kubebuilder:validation:Optional
	Global []VsphereCloudProviderGlobalParameters `json:"global,omitempty" tf:"global,omitempty"`

	// +kubebuilder:validation:Optional
	Network []VsphereCloudProviderNetworkParameters `json:"network,omitempty" tf:"network,omitempty"`

	// +kubebuilder:validation:Required
	VirtualCenter []VsphereCloudProviderVirtualCenterParameters `json:"virtualCenter" tf:"virtual_center,omitempty"`

	// +kubebuilder:validation:Required
	Workspace []VsphereCloudProviderWorkspaceParameters `json:"workspace" tf:"workspace,omitempty"`
}

type VsphereCloudProviderVirtualCenterObservation struct {
}

type VsphereCloudProviderVirtualCenterParameters struct {

	// +kubebuilder:validation:Required
	Datacenters *string `json:"datacenters" tf:"datacenters,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	PasswordSecretRef v1.SecretKeySelector `json:"passwordSecretRef" tf:"-"`

	// +kubebuilder:validation:Optional
	Port *string `json:"port,omitempty" tf:"port,omitempty"`

	// +kubebuilder:validation:Optional
	SoapRoundtripCount *float64 `json:"soapRoundtripCount,omitempty" tf:"soap_roundtrip_count,omitempty"`

	// +kubebuilder:validation:Required
	UserSecretRef v1.SecretKeySelector `json:"userSecretRef" tf:"-"`
}

type VsphereCloudProviderWorkspaceObservation struct {
}

type VsphereCloudProviderWorkspaceParameters struct {

	// +kubebuilder:validation:Required
	Datacenter *string `json:"datacenter" tf:"datacenter,omitempty"`

	// +kubebuilder:validation:Optional
	DefaultDatastore *string `json:"defaultDatastore,omitempty" tf:"default_datastore,omitempty"`

	// +kubebuilder:validation:Optional
	Folder *string `json:"folder,omitempty" tf:"folder,omitempty"`

	// +kubebuilder:validation:Optional
	ResourcepoolPath *string `json:"resourcepoolPath,omitempty" tf:"resourcepool_path,omitempty"`

	// +kubebuilder:validation:Required
	Server *string `json:"server" tf:"server,omitempty"`
}

type WeaveNetworkProviderObservation struct {
}

type WeaveNetworkProviderParameters struct {

	// +kubebuilder:validation:Required
	Password *string `json:"password" tf:"password,omitempty"`
}

type WebhookObservation struct {
}

type WebhookParameters struct {

	// Controls how long to cache authentication decisions
	// +kubebuilder:validation:Optional
	CacheTimeout *string `json:"cacheTimeout,omitempty" tf:"cache_timeout,omitempty"`

	// Multiline string that represent a custom webhook config file
	// +kubebuilder:validation:Optional
	ConfigFile *string `json:"configFile,omitempty" tf:"config_file,omitempty"`
}

type WorkerHostsObservation struct {
	Address *string `json:"address,omitempty" tf:"address,omitempty"`

	NodeName *string `json:"nodeName,omitempty" tf:"node_name,omitempty"`
}

type WorkerHostsParameters struct {
}

type WorkspaceObservation struct {
}

type WorkspaceParameters struct {

	// +kubebuilder:validation:Required
	Datacenter *string `json:"datacenter" tf:"datacenter,omitempty"`

	// +kubebuilder:validation:Optional
	DefaultDatastore *string `json:"defaultDatastore,omitempty" tf:"default_datastore,omitempty"`

	// +kubebuilder:validation:Optional
	Folder *string `json:"folder,omitempty" tf:"folder,omitempty"`

	// +kubebuilder:validation:Optional
	ResourcepoolPath *string `json:"resourcepoolPath,omitempty" tf:"resourcepool_path,omitempty"`

	// +kubebuilder:validation:Required
	Server *string `json:"server" tf:"server,omitempty"`
}

// ClusterSpec defines the desired state of Cluster
type ClusterSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ClusterParameters `json:"forProvider"`
}

// ClusterStatus defines the observed state of Cluster.
type ClusterStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ClusterObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Cluster is the Schema for the Clusters API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,rkejet}
type Cluster struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ClusterSpec   `json:"spec"`
	Status            ClusterStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ClusterList contains a list of Clusters
type ClusterList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Cluster `json:"items"`
}

// Repository type metadata.
var (
	Cluster_Kind             = "Cluster"
	Cluster_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Cluster_Kind}.String()
	Cluster_KindAPIVersion   = Cluster_Kind + "." + CRDGroupVersion.String()
	Cluster_GroupVersionKind = CRDGroupVersion.WithKind(Cluster_Kind)
)

func init() {
	SchemeBuilder.Register(&Cluster{}, &ClusterList{})
}
